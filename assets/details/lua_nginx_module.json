[
[4,"lua_load_resty_core","This directive is deprecated since the v0.10.16 release of this\nmodule. The resty.core module from\nlua-resty-core is now mandatorily\nloaded during the Lua VM initialization. Specifying this directive will have no\neffect.","<p dir=\"auto\">This directive is deprecated since the <code>v0.10.16</code> release of this\nmodule. The <code>resty.core</code> module from\n<a href=\"https://github.com/openresty/lua-resty-core\">lua-resty-core</a> is now mandatorily\nloaded during the Lua VM initialization. Specifying this directive will have no\neffect.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.15</code> release and\nused to optionally load the <code>resty.core</code> module.</p>",["This directive is deprecated since the v0.10.16 release of this\nmodule. The resty.core module from\nlua-resty-core is now mandatorily\nloaded during the Lua VM initialization. Specifying this directive will have no\neffect.","This directive was first introduced in the v0.10.15 release and\nused to optionally load the resty.core module."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_load_resty_core on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_load_resty_core on</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_capture_error_log","Enables a buffer of the specified size for capturing all the Nginx error log message data (not just those produced\nby this module or the Nginx http subsystem, but everything) without touching files or disks.","<p dir=\"auto\">Enables a buffer of the specified <code>size</code> for capturing all the Nginx error log message data (not just those produced\nby this module or the Nginx http subsystem, but everything) without touching files or disks.</p><p dir=\"auto\">You can use units like <code>k</code> and <code>m</code> in the <code>size</code> value, as in</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n lua_capture_error_log 100k;\n\"><pre> <span class=\"pl-k\">lua_capture_error_log</span> 100k;</pre></div><p dir=\"auto\">As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!</p><p dir=\"auto\">This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.</p><p dir=\"auto\">The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).</p><p dir=\"auto\">You can read the messages in the buffer on the Lua land via the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs\">get_logs()</a>\nfunction of the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme\">ngx.errlog</a>\nmodule of the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme\">lua-resty-core</a>\nlibrary. This Lua API function will return the captured error log messages and\nalso remove these already read from the global capturing buffer, making room\nfor any new error log data. For this reason, the user should not configure this\nbuffer to be too big if the user read the buffered error log data fast enough.</p><p dir=\"auto\">Note that the log level specified in the standard <a href=\"https://nginx.org/r/error_log\" rel=\"nofollow\">error_log</a> directive\n<em>does</em> have effect on this capturing facility. It only captures log\nmessages of a level no lower than the specified log level in the <a href=\"https://nginx.org/r/error_log\" rel=\"nofollow\">error_log</a> directive.\nThe user can still choose to set an even higher filtering log level on the fly via the Lua API function\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level\">errlog.set_filter_level</a>.\nSo it is more flexible than the static <a href=\"https://nginx.org/r/error_log\" rel=\"nofollow\">error_log</a> directive.</p><p dir=\"auto\">It is worth noting that there is no way to capture the debugging logs\nwithout building OpenResty or Nginx with the <code>./configure</code>\noption <code>--with-debug</code>. And enabling debugging logs is\nstrongly discouraged in production builds due to high overhead.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.9</code> release.</p>",["Enables a buffer of the specified size for capturing all the Nginx error log message data (not just those produced\nby this module or the Nginx http subsystem, but everything) without touching files or disks.","You can use units like k and m in the size value, as in"," lua_capture_error_log 100k;","As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!","This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.","The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).","You can read the messages in the buffer on the Lua land via the\nget_logs()\nfunction of the\nngx.errlog\nmodule of the lua-resty-core\nlibrary. This Lua API function will return the captured error log messages and\nalso remove these already read from the global capturing buffer, making room\nfor any new error log data. For this reason, the user should not configure this\nbuffer to be too big if the user read the buffered error log data fast enough.","Note that the log level specified in the standard error_log directive\ndoes have effect on this capturing facility. It only captures log\nmessages of a level no lower than the specified log level in the error_log directive.\nThe user can still choose to set an even higher filtering log level on the fly via the Lua API function\nerrlog.set_filter_level.\nSo it is more flexible than the static error_log directive.","It is worth noting that there is no way to capture the debugging logs\nwithout building OpenResty or Nginx with the ./configure\noption --with-debug. And enabling debugging logs is\nstrongly discouraged in production builds due to high overhead.","This directive was first introduced in the v0.10.9 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_capture_error_log size</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_capture_error_log ;</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_use_default_type","Specifies whether to use the MIME type specified by the default_type directive for the default value of the Content-Type response header. Deactivate this directive if a default Content-Type response header for Lua request handlers is not desired.","<p dir=\"auto\">Specifies whether to use the MIME type specified by the <a href=\"https://nginx.org/en/docs/http/ngx_http_core_module.html#default_type\" rel=\"nofollow\">default_type</a> directive for the default value of the <code>Content-Type</code> response header. Deactivate this directive if a default <code>Content-Type</code> response header for Lua request handlers is not desired.</p><p dir=\"auto\">This directive is turned on by default.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.1</code> release.</p>",["Specifies whether to use the MIME type specified by the default_type directive for the default value of the Content-Type response header. Deactivate this directive if a default Content-Type response header for Lua request handlers is not desired.","This directive is turned on by default.","This directive was first introduced in the v0.9.1 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_use_default_type on | off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_use_default_type on</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"lua_malloc_trim","Asks the underlying libc runtime library to release its cached free memory back to the operating system every\nN requests processed by the Nginx core. By default, N is 1000. You can configure the request count\nby using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and\nsmaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint.\nJust tune the number for your own use cases.","<p dir=\"auto\">Asks the underlying <code>libc</code> runtime library to release its cached free memory back to the operating system every\n<code>N</code> requests processed by the Nginx core. By default, <code>N</code> is 1000. You can configure the request count\nby using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and\nsmaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint.\nJust tune the number for your own use cases.</p><p dir=\"auto\">Configuring the argument to <code>0</code> essentially turns off the periodical memory trimming altogether.</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n lua_malloc_trim 0;  # turn off trimming completely\n\"><pre> <span class=\"pl-k\">lua_malloc_trim</span> 0;  <span class=\"pl-c\"># turn off trimming completely</span></pre></div><p dir=\"auto\">The current implementation uses an Nginx log phase handler to do the request counting. So the appearance of the\n<a href=\"https://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest\" rel=\"nofollow\">log_subrequest on</a> directives in <code>nginx.conf</code>\nmay make the counting faster when subrequests are involved. By default, only \"main requests\" count.</p><p dir=\"auto\">Note that this directive does <em>not</em> affect the memory allocated by LuaJIT's own allocator based on the <code>mmap</code>\nsystem call.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.7</code> release.</p>",["Asks the underlying libc runtime library to release its cached free memory back to the operating system every\nN requests processed by the Nginx core. By default, N is 1000. You can configure the request count\nby using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and\nsmaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint.\nJust tune the number for your own use cases.","Configuring the argument to 0 essentially turns off the periodical memory trimming altogether."," lua_malloc_trim 0;  # turn off trimming completely","The current implementation uses an Nginx log phase handler to do the request counting. So the appearance of the\nlog_subrequest on directives in nginx.conf\nmay make the counting faster when subrequests are involved. By default, only \"main requests\" count.","Note that this directive does not affect the memory allocated by LuaJIT's own allocator based on the mmap\nsystem call.","This directive was first introduced in the v0.10.7 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_malloc_trim <request-count></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_malloc_trim 1000</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_code_cache","Enables or disables the Lua code cache for Lua code in *_by_lua_file directives (like set_by_lua_file and\ncontent_by_lua_file) and Lua modules.","<p dir=\"auto\">Enables or disables the Lua code cache for Lua code in <code>*_by_lua_file</code> directives (like <a href=\"#set_by_lua_file\">set_by_lua_file</a> and\n<a href=\"#content_by_lua_file\">content_by_lua_file</a>) and Lua modules.</p><p dir=\"auto\">When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the <code>0.9.3</code> release. So the Lua files referenced in <a href=\"#set_by_lua_file\">set_by_lua_file</a>,\n<a href=\"#content_by_lua_file\">content_by_lua_file</a>, <a href=\"#access_by_lua_file\">access_by_lua_file</a>,\nand etc will not be cached\nand all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.</p><p dir=\"auto\">Please note however, that Lua code written inlined within nginx.conf\nsuch as those specified by <a href=\"#set_by_lua\">set_by_lua</a>, <a href=\"#content_by_lua\">content_by_lua</a>,\n<a href=\"#access_by_lua\">access_by_lua</a>, and <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> will not be updated when you edit the inlined Lua code in your <code>nginx.conf</code> file because only the Nginx config file parser can correctly parse the <code>nginx.conf</code>\nfile and the only way is to reload the config file\nby sending a <code>HUP</code> signal or just to restart Nginx.</p><p dir=\"auto\">Even when the code cache is enabled, Lua files which are loaded by <code>dofile</code> or <code>loadfile</code>\nin *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the <a href=\"#init_by_lua\">init_by_lua</a>\nor <a href=\"#init-by_lua_file\">init_by_lua_file</a> directives to load all such files or just make these Lua files true Lua modules\nand load them via <code>require</code>.</p><p dir=\"auto\">The ngx_lua module does not support the <code>stat</code> mode available with the\nApache <code>mod_lua</code> module (yet).</p><p dir=\"auto\">Disabling the Lua code cache is strongly\ndiscouraged for production use and should only be used during\ndevelopment as it has a significant negative impact on overall performance. For example, the performance of a \"hello world\" Lua example can drop by an order of magnitude after disabling the Lua code cache.</p>",["Enables or disables the Lua code cache for Lua code in *_by_lua_file directives (like set_by_lua_file and\ncontent_by_lua_file) and Lua modules.","When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the 0.9.3 release. So the Lua files referenced in set_by_lua_file,\ncontent_by_lua_file, access_by_lua_file,\nand etc will not be cached\nand all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.","Please note however, that Lua code written inlined within nginx.conf\nsuch as those specified by set_by_lua, content_by_lua,\naccess_by_lua, and rewrite_by_lua will not be updated when you edit the inlined Lua code in your nginx.conf file because only the Nginx config file parser can correctly parse the nginx.conf\nfile and the only way is to reload the config file\nby sending a HUP signal or just to restart Nginx.","Even when the code cache is enabled, Lua files which are loaded by dofile or loadfile\nin *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the init_by_lua\nor init_by_lua_file directives to load all such files or just make these Lua files true Lua modules\nand load them via require.","The ngx_lua module does not support the stat mode available with the\nApache mod_lua module (yet).","Disabling the Lua code cache is strongly\ndiscouraged for production use and should only be used during\ndevelopment as it has a significant negative impact on overall performance. For example, the performance of a \"hello world\" Lua example can drop by an order of magnitude after disabling the Lua code cache."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_code_cache on | off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_code_cache on</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"lua_thread_cache_max_entries","Specifies the maximum number of entries allowed in the worker process level lua thread object cache.","<p dir=\"auto\">Specifies the maximum number of entries allowed in the worker process level lua thread object cache.</p><p dir=\"auto\">This cache recycles the lua thread GC objects among all our \"light threads\".</p><p dir=\"auto\">A zero value of <code>&lt;num&gt;</code> disables the cache.</p><p dir=\"auto\">Note that this feature requires OpenResty's LuaJIT with the new C API <code>lua_resetthread</code>.</p><p dir=\"auto\">This feature was first introduced in verson <code>v0.10.9</code>.</p>",["Specifies the maximum number of entries allowed in the worker process level lua thread object cache.","This cache recycles the lua thread GC objects among all our \"light threads\".","A zero value of <num> disables the cache.","Note that this feature requires OpenResty's LuaJIT with the new C API lua_resetthread.","This feature was first introduced in verson v0.10.9."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_thread_cache_max_entries <num></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_thread_cache_max_entries 1024</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_regex_cache_max_entries","Specifies the maximum number of entries allowed in the worker process level compiled regex cache.","<p dir=\"auto\">Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</p><p dir=\"auto\">The regular expressions used in <a href=\"#ngxrematch\">ngx.re.match</a>, <a href=\"#ngxregmatch\">ngx.re.gmatch</a>, <a href=\"#ngxresub\">ngx.re.sub</a>, and <a href=\"#ngxregsub\">ngx.re.gsub</a> will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.</p><p dir=\"auto\">The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:</p><div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...\n\"><pre><code>2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...\n</code></pre></div><p dir=\"auto\">If you are using the <code>ngx.re.*</code> implementation of <a href=\"https://github.com/openresty/lua-resty-core\">lua-resty-core</a> by loading the <code>resty.core.regex</code> module (or just the <code>resty.core</code> module), then an LRU cache is used for the regex cache being used here.</p><p dir=\"auto\">Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for <a href=\"#ngxresub\">ngx.re.sub</a> and <a href=\"#ngxregsub\">ngx.re.gsub</a>) that are generated <em>on the fly</em> and give rise to infinite variations to avoid hitting the specified limit.</p>",["Specifies the maximum number of entries allowed in the worker process level compiled regex cache.","The regular expressions used in ngx.re.match, ngx.re.gmatch, ngx.re.sub, and ngx.re.gsub will be cached within this cache if the regex option o (i.e., compile-once flag) is specified.","The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the o option was not specified) and there will be one, and only one, warning in the error.log file:","2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...\n","If you are using the ngx.re.* implementation of lua-resty-core by loading the resty.core.regex module (or just the resty.core module), then an LRU cache is used for the regex cache being used here.","Do not activate the o option for regular expressions (and/or replace string arguments for ngx.re.sub and ngx.re.gsub) that are generated on the fly and give rise to infinite variations to avoid hitting the specified limit."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_regex_cache_max_entries <num></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_regex_cache_max_entries 1024</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_regex_match_limit","Specifies the \"match limit\" used by the PCRE library when executing the ngx.re API. To quote the PCRE manpage, \"the limit ... has the effect of limiting the amount of backtracking that can take place.\"","<p dir=\"auto\">Specifies the \"match limit\" used by the PCRE library when executing the <a href=\"#ngxrematch\">ngx.re API</a>. To quote the PCRE manpage, \"the limit ... has the effect of limiting the amount of backtracking that can take place.\"</p><p dir=\"auto\">When the limit is hit, the error string \"pcre_exec() failed: -8\" will be returned by the <a href=\"#ngxrematch\">ngx.re API</a> functions on the Lua land.</p><p dir=\"auto\">When setting the limit to 0, the default \"match limit\" when compiling the PCRE library is used. And this is the default value of this directive.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.8.5</code> release.</p>",["Specifies the \"match limit\" used by the PCRE library when executing the ngx.re API. To quote the PCRE manpage, \"the limit ... has the effect of limiting the amount of backtracking that can take place.\"","When the limit is hit, the error string \"pcre_exec() failed: -8\" will be returned by the ngx.re API functions on the Lua land.","When setting the limit to 0, the default \"match limit\" when compiling the PCRE library is used. And this is the default value of this directive.","This directive was first introduced in the v0.8.5 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_regex_match_limit <num></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_regex_match_limit 0</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_package_path","Sets the Lua module search path used by scripts specified by set_by_lua,\ncontent_by_lua and others. The path string is in standard Lua path form, and ;;\ncan be used to stand for the original search paths.","<p dir=\"auto\">Sets the Lua module search path used by scripts specified by <a href=\"#set_by_lua\">set_by_lua</a>,\n<a href=\"#content_by_lua\">content_by_lua</a> and others. The path string is in standard Lua path form, and <code>;;</code>\ncan be used to stand for the original search paths.</p><p dir=\"auto\">As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>",["Sets the Lua module search path used by scripts specified by set_by_lua,\ncontent_by_lua and others. The path string is in standard Lua path form, and ;;\ncan be used to stand for the original search paths.","As from the v0.5.0rc29 release, the special notation $prefix or ${prefix} can be used in the search path string to indicate the path of the server prefix usually determined by the -p PATH command-line option while starting the Nginx server."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_package_path <lua-style-path-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>The content of LUA_PATH environment variable or Lua's compiled-in defaults.</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_package_cpath","Sets the Lua C-module search path used by scripts specified by set_by_lua,\ncontent_by_lua and others. The cpath string is in standard Lua cpath form, and ;;\ncan be used to stand for the original cpath.","<p dir=\"auto\">Sets the Lua C-module search path used by scripts specified by <a href=\"#set_by_lua\">set_by_lua</a>,\n<a href=\"#content_by_lua\">content_by_lua</a> and others. The cpath string is in standard Lua cpath form, and <code>;;</code>\ncan be used to stand for the original cpath.</p><p dir=\"auto\">As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>",["Sets the Lua C-module search path used by scripts specified by set_by_lua,\ncontent_by_lua and others. The cpath string is in standard Lua cpath form, and ;;\ncan be used to stand for the original cpath.","As from the v0.5.0rc29 release, the special notation $prefix or ${prefix} can be used in the search path string to indicate the path of the server prefix usually determined by the -p PATH command-line option while starting the Nginx server."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_package_cpath <lua-style-cpath-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>The content of LUA_CPATH environment variable or Lua's compiled-in defaults.</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"init_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the init_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#init_by_lua_block\">init_by_lua_block</a> directive instead.</p><p dir=\"auto\">Runs the Lua code specified by the argument <code>&lt;lua-script-str&gt;</code> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</p><p dir=\"auto\">When Nginx receives the <code>HUP</code> signal and starts reloading the config file, the Lua VM will also be re-created and <code>init_by_lua</code> will run again on the new Lua VM. In case that the <a href=\"#lua_code_cache\">lua_code_cache</a> directive is turned off (default on), the <code>init_by_lua</code> handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.</p><p dir=\"auto\">Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems' copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n # this runs before forking out nginx worker processes:\n init_by_lua_block { require &quot;cjson&quot; }\n\n server {\n     location = /api {\n         content_by_lua_block {\n             -- the following require() will just  return\n             -- the already loaded module from package.loaded:\n             ngx.say(require &quot;cjson&quot;.encode{dog = 5, cat = 6})\n         }\n     }\n }\n\"><pre> <span class=\"pl-c\"># this runs before forking out nginx worker processes:</span>\n <span class=\"pl-k\">init_by_lua_block</span> { require <span class=\"pl-s\">\"cjson\"</span> }\n\n <span class=\"pl-k\">server</span> {\n     <span class=\"pl-k\">location</span> <span class=\"pl-en\">= /api </span>{\n         <span class=\"pl-k\">content_by_lua_block</span> {\n             -- <span class=\"pl-k\">the</span> following require() will just  return\n             -- <span class=\"pl-k\">the</span> already loaded module from package.loaded:\n             ngx.say(<span class=\"pl-k\">require</span> <span class=\"pl-s\">\"cjson\"</span>.encode{dog = 5, cat = 6})\n         }\n     }\n }</pre></div><p dir=\"auto\">You can also initialize the <a href=\"#lua_shared_dict\">lua_shared_dict</a> shm storage at this phase. Here is an example for this:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n lua_shared_dict dogs 1m;\n\n init_by_lua_block {\n     local dogs = ngx.shared.dogs\n     dogs:set(&quot;Tom&quot;, 56)\n }\n\n server {\n     location = /api {\n         content_by_lua_block {\n             local dogs = ngx.shared.dogs\n             ngx.say(dogs:get(&quot;Tom&quot;))\n         }\n     }\n }\n\"><pre> <span class=\"pl-k\">lua_shared_dict</span> dogs <span class=\"pl-c1\">1m</span>;\n\n <span class=\"pl-k\">init_by_lua_block</span> {\n     <span class=\"pl-k\">local</span> dogs = ngx.shared.dogs\n     dogs:<span class=\"pl-k\">set</span>(<span class=\"pl-s\">\"Tom\"</span>, 56)\n }\n\n server {\n     location = /api {\n         content_by_lua_block {\n             local dogs = ngx.shared.dogs\n             ngx.say(dogs:get(<span class=\"pl-s\">\"Tom\"</span>))\n         }\n     }\n }</pre></div><p dir=\"auto\">But note that, the <a href=\"#lua_shared_dict\">lua_shared_dict</a>'s shm storage will not be cleared through a config reload (via the <code>HUP</code> signal, for example). So if you do <em>not</em> want to re-initialize the shm storage in your <code>init_by_lua</code> code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your <code>init_by_lua</code> code.</p><p dir=\"auto\">Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the <a href=\"https://en.wikipedia.org/wiki/Copy-on-write\" rel=\"nofollow\">Copy-on-write (COW)</a> feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</p><p dir=\"auto\">Do <em>not</em> initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the <a href=\"#lua-variable-scope\">Lua Variable Scope</a> section for more details). The recommended way is to use proper <a href=\"https://www.lua.org/manual/5.1/manual.html#5.3\" rel=\"nofollow\">Lua module</a> files (but do not use the standard Lua function <a href=\"https://www.lua.org/manual/5.1/manual.html#pdf-module\" rel=\"nofollow\">module()</a> to define Lua modules because it pollutes the global namespace as well) and call <a href=\"https://www.lua.org/manual/5.1/manual.html#pdf-require\" rel=\"nofollow\">require()</a> to load your own module files in <code>init_by_lua</code> or other contexts (<a href=\"https://www.lua.org/manual/5.1/manual.html#pdf-require\" rel=\"nofollow\">require()</a> does cache the loaded Lua modules in the global <code>package.loaded</code> table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</p><p dir=\"auto\">Only a small set of the <a href=\"#nginx-api-for-lua\">Nginx API for Lua</a> is supported in this context:</p><ul dir=\"auto\">\n<li>Logging APIs: <a href=\"#ngxlog\">ngx.log</a> and <a href=\"#print\">print</a>,</li>\n<li>Shared Dictionary API: <a href=\"#ngxshareddict\">ngx.shared.DICT</a>.</li>\n</ul><p dir=\"auto\">More Nginx APIs for Lua may be supported in this context upon future user requests.</p><p dir=\"auto\">Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.</p><p dir=\"auto\">You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the <code>root</code> account.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.5</code> release.</p><p dir=\"auto\">See also the following blog posts for more details on OpenResty and Nginx's shared memory zones:</p><ul dir=\"auto\">\n<li><a href=\"https://blog.openresty.com/en/how-nginx-shm-consume-ram/?src=gh_ngxlua\" rel=\"nofollow\">How OpenResty and Nginx Shared Memory Zones Consume RAM</a></li>\n<li><a href=\"https://blog.openresty.com/en/nginx-shm-frag/?src=gh_ngxlua\" rel=\"nofollow\">Memory Fragmentation in OpenResty and Nginx's Shared Memory Zones</a></li>\n</ul>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the init_by_lua_block directive instead.","Runs the Lua code specified by the argument <lua-script-str> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.","When Nginx receives the HUP signal and starts reloading the config file, the Lua VM will also be re-created and init_by_lua will run again on the new Lua VM. In case that the lua_code_cache directive is turned off (default on), the init_by_lua handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.","Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems' copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:"," # this runs before forking out nginx worker processes:\n init_by_lua_block { require \"cjson\" }\n\n server {\n     location = /api {\n         content_by_lua_block {\n             -- the following require() will just  return\n             -- the already loaded module from package.loaded:\n             ngx.say(require \"cjson\".encode{dog = 5, cat = 6})\n         }\n     }\n }","You can also initialize the lua_shared_dict shm storage at this phase. Here is an example for this:"," lua_shared_dict dogs 1m;\n\n init_by_lua_block {\n     local dogs = ngx.shared.dogs\n     dogs:set(\"Tom\", 56)\n }\n\n server {\n     location = /api {\n         content_by_lua_block {\n             local dogs = ngx.shared.dogs\n             ngx.say(dogs:get(\"Tom\"))\n         }\n     }\n }","But note that, the lua_shared_dict's shm storage will not be cleared through a config reload (via the HUP signal, for example). So if you do not want to re-initialize the shm storage in your init_by_lua code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your init_by_lua code.","Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the Copy-on-write (COW) feature provided by many operating systems among all the worker processes, thus saving a lot of memory.","Do not initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the Lua Variable Scope section for more details). The recommended way is to use proper Lua module files (but do not use the standard Lua function module() to define Lua modules because it pollutes the global namespace as well) and call require() to load your own module files in init_by_lua or other contexts (require() does cache the loaded Lua modules in the global package.loaded table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).","Only a small set of the Nginx API for Lua is supported in this context:","\nLogging APIs: ngx.log and print,\nShared Dictionary API: ngx.shared.DICT.\n","More Nginx APIs for Lua may be supported in this context upon future user requests.","Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream's host names) at the configure-loading phase.","You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the root account.","This directive was first introduced in the v0.5.5 release.","See also the following blog posts for more details on OpenResty and Nginx's shared memory zones:","\nHow OpenResty and Nginx Shared Memory Zones Consume RAM\nMemory Fragmentation in OpenResty and Nginx's Shared Memory Zones\n"],"<table ><tr><th>Syntax:</th><td><code><strong>init_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"init_by_lua_block","Similar to the init_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#init_by_lua\">init_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n init_by_lua_block {\n     print(&quot;I need no extra escaping here, for example: \\r\\nblah&quot;)\n }\n\"><pre> <span class=\"pl-k\">init_by_lua_block</span> {\n     print(\"<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the init_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," init_by_lua_block {\n     print(\"I need no extra escaping here, for example: \\r\\nblah\")\n }","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>init_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"init_by_lua_file","Equivalent to init_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code or LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#init_by_lua\">init_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code or <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.5</code> release.</p>",["Equivalent to init_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code or LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.5.5 release."],"<table ><tr><th>Syntax:</th><td><code><strong>init_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"init_worker_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the init_worker_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#init_worker_by_lua_block\">init_worker_by_lua_block</a> directive instead.</p><p dir=\"auto\">Runs the specified Lua code upon every Nginx worker process's startup when the master process is enabled. When the master process is disabled, this hook will just run after <a href=\"#init_by_lua\">init_by_lua*</a>.</p><p dir=\"auto\">This hook is often used to create per-worker reoccurring timers (via the <a href=\"#ngxtimerat\">ngx.timer.at</a> Lua API), either for backend health-check or other timed routine work. Below is an example,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n init_worker_by_lua '\n     local delay = 3  -- in seconds\n     local new_timer = ngx.timer.at\n     local log = ngx.log\n     local ERR = ngx.ERR\n     local check\n\n     check = function(premature)\n         if not premature then\n             -- do the health check or other routine work\n             local ok, err = new_timer(delay, check)\n             if not ok then\n                 log(ERR, &quot;failed to create timer: &quot;, err)\n                 return\n             end\n         end\n\n         -- do something in timer\n     end\n\n     local hdl, err = new_timer(delay, check)\n     if not hdl then\n         log(ERR, &quot;failed to create timer: &quot;, err)\n         return\n     end\n\n     -- other job in init_worker_by_lua\n ';\n\"><pre> <span class=\"pl-k\">init_worker_by_lua</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">     local delay = 3  -- in seconds</span>\n<span class=\"pl-s\">     local new_timer = ngx.timer.at</span>\n<span class=\"pl-s\">     local log = ngx.log</span>\n<span class=\"pl-s\">     local ERR = ngx.ERR</span>\n<span class=\"pl-s\">     local check</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">     check = function(premature)</span>\n<span class=\"pl-s\">         if not premature then</span>\n<span class=\"pl-s\">             -- do the health check or other routine work</span>\n<span class=\"pl-s\">             local ok, err = new_timer(delay, check)</span>\n<span class=\"pl-s\">             if not ok then</span>\n<span class=\"pl-s\">                 log(ERR, \"failed to create timer: \", err)</span>\n<span class=\"pl-s\">                 return</span>\n<span class=\"pl-s\">             end</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         -- do something in timer</span>\n<span class=\"pl-s\">     end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">     local hdl, err = new_timer(delay, check)</span>\n<span class=\"pl-s\">     if not hdl then</span>\n<span class=\"pl-s\">         log(ERR, \"failed to create timer: \", err)</span>\n<span class=\"pl-s\">         return</span>\n<span class=\"pl-s\">     end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">     -- other job in init_worker_by_lua</span>\n<span class=\"pl-s\"> '</span>;</pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.5</code> release.</p><p dir=\"auto\">This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the init_worker_by_lua_block directive instead.","Runs the specified Lua code upon every Nginx worker process's startup when the master process is enabled. When the master process is disabled, this hook will just run after init_by_lua*.","This hook is often used to create per-worker reoccurring timers (via the ngx.timer.at Lua API), either for backend health-check or other timed routine work. Below is an example,"," init_worker_by_lua '\n     local delay = 3  -- in seconds\n     local new_timer = ngx.timer.at\n     local log = ngx.log\n     local ERR = ngx.ERR\n     local check\n\n     check = function(premature)\n         if not premature then\n             -- do the health check or other routine work\n             local ok, err = new_timer(delay, check)\n             if not ok then\n                 log(ERR, \"failed to create timer: \", err)\n                 return\n             end\n         end\n\n         -- do something in timer\n     end\n\n     local hdl, err = new_timer(delay, check)\n     if not hdl then\n         log(ERR, \"failed to create timer: \", err)\n         return\n     end\n\n     -- other job in init_worker_by_lua\n ';","This directive was first introduced in the v0.9.5 release.","This hook no longer runs in the cache manager and cache loader processes since the v0.10.12 release."],"<table ><tr><th>Syntax:</th><td><code><strong>init_worker_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_worker_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"init_worker_by_lua_block","Similar to the init_worker_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#init_worker_by_lua\">init_worker_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n init_worker_by_lua_block {\n     print(&quot;I need no extra escaping here, for example: \\r\\nblah&quot;)\n }\n\"><pre> <span class=\"pl-k\">init_worker_by_lua_block</span> {\n     print(\"<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p><p dir=\"auto\">This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>",["Similar to the init_worker_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," init_worker_by_lua_block {\n     print(\"I need no extra escaping here, for example: \\r\\nblah\")\n }","This directive was first introduced in the v0.9.17 release.","This hook no longer runs in the cache manager and cache loader processes since the v0.10.12 release."],"<table ><tr><th>Syntax:</th><td><code><strong>init_worker_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_worker_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"init_worker_by_lua_file","Similar to init_worker_by_lua, but accepts the file path to a Lua source file or Lua bytecode file.","<p dir=\"auto\">Similar to <a href=\"#init_worker_by_lua\">init_worker_by_lua</a>, but accepts the file path to a Lua source file or Lua bytecode file.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.5</code> release.</p><p dir=\"auto\">This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>",["Similar to init_worker_by_lua, but accepts the file path to a Lua source file or Lua bytecode file.","This directive was first introduced in the v0.9.5 release.","This hook no longer runs in the cache manager and cache loader processes since the v0.10.12 release."],"<table ><tr><th>Syntax:</th><td><code><strong>init_worker_by_lua_file <lua-file-path></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_worker_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"exit_worker_by_lua_block","Runs the specified Lua code upon every Nginx worker process's exit when the master process is enabled. When the master process is disabled, this hook will run before the Nginx process exits.","<p dir=\"auto\">Runs the specified Lua code upon every Nginx worker process's exit when the master process is enabled. When the master process is disabled, this hook will run before the Nginx process exits.</p><p dir=\"auto\">This hook is often used to release resources allocated by each worker (e.g. resources allocated by <a href=\"#init_worker_by_lua\">init_worker_by_lua*</a>), or to prevent workers from exiting abnormally.</p><p dir=\"auto\">For example,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n exit_worker_by_lua_block {\n     print(&quot;log from exit_worker_by_lua_block&quot;)\n }\n\"><pre> <span class=\"pl-k\">exit_worker_by_lua_block</span> {\n     print(\"<span class=\"pl-k\">log</span> from exit_worker_by_lua_block<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">It's not allowed to create a timer (even a 0-delay timer) here since it runs after all timers have been processed.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.18</code> release.</p>",["Runs the specified Lua code upon every Nginx worker process's exit when the master process is enabled. When the master process is disabled, this hook will run before the Nginx process exits.","This hook is often used to release resources allocated by each worker (e.g. resources allocated by init_worker_by_lua*), or to prevent workers from exiting abnormally.","For example,"," exit_worker_by_lua_block {\n     print(\"log from exit_worker_by_lua_block\")\n }","It's not allowed to create a timer (even a 0-delay timer) here since it runs after all timers have been processed.","This directive was first introduced in the v0.10.18 release."],"<table ><tr><th>Syntax:</th><td><code><strong>exit_worker_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>exit_worker_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"exit_worker_by_lua_file","Similar to exit_worker_by_lua_block, but accepts the file path to a Lua source file or Lua bytecode file.","<p dir=\"auto\">Similar to <a href=\"#exit_worker_by_lua_block\">exit_worker_by_lua_block</a>, but accepts the file path to a Lua source file or Lua bytecode file.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.18</code> release.</p>",["Similar to exit_worker_by_lua_block, but accepts the file path to a Lua source file or Lua bytecode file.","This directive was first introduced in the v0.10.18 release."],"<table ><tr><th>Syntax:</th><td><code><strong>exit_worker_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>exit_worker_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"set_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the set_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#set_by_lua_block\">set_by_lua_block</a> directive instead.</p><p dir=\"auto\">Executes code specified in <code>&lt;lua-script-str&gt;</code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>.\nThe code in <code>&lt;lua-script-str&gt;</code> can make <a href=\"#nginx-api-for-lua\">API calls</a> and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).</p><p dir=\"auto\">This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.</p><p dir=\"auto\">This directive is implemented by injecting custom commands into the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>'s command list. Because <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a> does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua \"light thread\" cannot work in this directive.</p><p dir=\"auto\">At least the following API functions are currently disabled within the context of <code>set_by_lua</code>:</p><ul dir=\"auto\">\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxexit\">ngx.exit</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n<li>Sleeping API function <a href=\"#ngxsleep\">ngx.sleep</a>.</li>\n</ul><p dir=\"auto\">In addition, note that this directive can only write out a value to a single Nginx variable at\na time. However, a workaround is possible using the <a href=\"#ngxvarvariable\">ngx.var.VARIABLE</a> interface.</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location /foo {\n     set $diff ''; # we have to predefine the $diff variable here\n\n     set_by_lua $sum '\n         local a = 32\n         local b = 56\n\n         ngx.var.diff = a - b  -- write to $diff directly\n         return a + b          -- return the $sum value normally\n     ';\n\n     echo &quot;sum = $sum, diff = $diff&quot;;\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$diff</span> <span class=\"pl-s\">''</span>; <span class=\"pl-c\"># we have to predefine the $diff variable here</span>\n\n     <span class=\"pl-k\">set_by_lua</span> <span class=\"pl-smi\">$sum</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">         local a = 32</span>\n<span class=\"pl-s\">         local b = 56</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         ngx.var.diff = a - b  -- write to <span class=\"pl-smi\">$diff</span> directly</span>\n<span class=\"pl-s\">         return a + b          -- return the <span class=\"pl-smi\">$sum</span> value normally</span>\n<span class=\"pl-s\">     '</span>;\n\n     <span class=\"pl-k\">echo</span> <span class=\"pl-s\">\"sum = <span class=\"pl-smi\">$sum</span>, diff = <span class=\"pl-smi\">$diff</span>\"</span>;\n }</pre></div><p dir=\"auto\">This directive can be freely mixed with all directives of the <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>, <a href=\"http://github.com/openresty/set-misc-nginx-module\">set-misc-nginx-module</a>, and <a href=\"http://github.com/openresty/array-var-nginx-module\">array-var-nginx-module</a> modules. All of these directives will run in the same order as they appear in the config file.</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n set $foo 32;\n set_by_lua $bar 'return tonumber(ngx.var.foo) + 1';\n set $baz &quot;bar: $bar&quot;;  # $baz == &quot;bar: 33&quot;\n\"><pre> <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$foo</span> <span class=\"pl-s\">32</span>;\n <span class=\"pl-k\">set_by_lua</span> <span class=\"pl-smi\">$bar</span> <span class=\"pl-s\">'return tonumber(ngx.var.foo) + 1'</span>;\n <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$baz</span> <span class=\"pl-s\">\"bar: <span class=\"pl-smi\">$bar</span>\"</span>;  <span class=\"pl-c\"># $baz == \"bar: 33\"</span></pre></div><p dir=\"auto\">As from the <code>v0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code>&lt;lua-script-str&gt;</code> argument of this directive and therefore, the dollar sign character (<code>$</code>) can be used directly.</p><p dir=\"auto\">This directive requires the <a href=\"https://github.com/simplresty/ngx_devel_kit\">ngx_devel_kit</a> module.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the set_by_lua_block directive instead.","Executes code specified in <lua-script-str> with optional input arguments $arg1 $arg2 ..., and returns string output to $res.\nThe code in <lua-script-str> can make API calls and can retrieve input arguments from the ngx.arg table (index starts from 1 and increases sequentially).","This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.","This directive is implemented by injecting custom commands into the standard ngx_http_rewrite_module's command list. Because ngx_http_rewrite_module does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua \"light thread\" cannot work in this directive.","At least the following API functions are currently disabled within the context of set_by_lua:","\nOutput API functions (e.g., ngx.say and ngx.send_headers)\nControl API functions (e.g., ngx.exit)\nSubrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi)\nCosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).\nSleeping API function ngx.sleep.\n","In addition, note that this directive can only write out a value to a single Nginx variable at\na time. However, a workaround is possible using the ngx.var.VARIABLE interface."," location /foo {\n     set $diff ''; # we have to predefine the $diff variable here\n\n     set_by_lua $sum '\n         local a = 32\n         local b = 56\n\n         ngx.var.diff = a - b  -- write to $diff directly\n         return a + b          -- return the $sum value normally\n     ';\n\n     echo \"sum = $sum, diff = $diff\";\n }","This directive can be freely mixed with all directives of the ngx_http_rewrite_module, set-misc-nginx-module, and array-var-nginx-module modules. All of these directives will run in the same order as they appear in the config file."," set $foo 32;\n set_by_lua $bar 'return tonumber(ngx.var.foo) + 1';\n set $baz \"bar: $bar\";  # $baz == \"bar: 33\"","As from the v0.5.0rc29 release, Nginx variable interpolation is disabled in the <lua-script-str> argument of this directive and therefore, the dollar sign character ($) can be used directly.","This directive requires the ngx_devel_kit module."],"<table ><tr><th>Syntax:</th><td><code><strong>set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]</strong></code><br></td></tr><tr><th>Default:</th><td><pre>set_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>server</code>,<code>server if</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"set_by_lua_block","Similar to the set_by_lua directive except that","<p dir=\"auto\">Similar to the <a href=\"#set_by_lua\">set_by_lua</a> directive except that</p><ol dir=\"auto\">\n<li>this directive inlines the Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping), and</li>\n<li>this directive does not support extra arguments after the Lua script as in <a href=\"#set_by_lua\">set_by_lua</a>.</li>\n</ol><p dir=\"auto\">For example,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n set_by_lua_block $res { return 32 + math.cos(32) }\n # $res now has the value &quot;32.834223360507&quot; or alike.\n\"><pre> <span class=\"pl-k\">set_by_lua_block</span> <span class=\"pl-smi\">$res</span> { return <span class=\"pl-s\">32</span> + math.cos(32) }\n <span class=\"pl-c\"># $res now has the value \"32.834223360507\" or alike.</span></pre></div><p dir=\"auto\">No special escaping is required in the Lua code block.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the set_by_lua directive except that","\nthis directive inlines the Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping), and\nthis directive does not support extra arguments after the Lua script as in set_by_lua.\n","For example,"," set_by_lua_block $res { return 32 + math.cos(32) }\n # $res now has the value \"32.834223360507\" or alike.","No special escaping is required in the Lua code block.","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>set_by_lua_block $res { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>set_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>server</code>,<code>server if</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"set_by_lua_file","Equivalent to set_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#set_by_lua\">set_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">Nginx variable interpolation is supported in the <code>&lt;path-to-lua-script-file&gt;</code> argument string of this directive. But special care must be taken for injection attacks.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by\nswitching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p dir=\"auto\">This directive requires the <a href=\"https://github.com/simplresty/ngx_devel_kit\">ngx_devel_kit</a> module.</p>",["Equivalent to set_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","Nginx variable interpolation is supported in the <path-to-lua-script-file> argument string of this directive. But special care must be taken for injection attacks.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by\nswitching lua_code_cache off in nginx.conf to avoid reloading Nginx.","This directive requires the ngx_devel_kit module."],"<table ><tr><th>Syntax:</th><td><code><strong>set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 ...]</strong></code><br></td></tr><tr><th>Default:</th><td><pre>set_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>server</code>,<code>server if</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"content_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the content_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#content_by_lua_block\">content_by_lua_block</a> directive instead.</p><p dir=\"auto\">Acts as a \"content handler\" and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.\nThe Lua code may make <a href=\"#nginx-api-for-lua\">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p dir=\"auto\">Do not use this directive and other content handler directives in the same location. For example, this directive and the <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass\" rel=\"nofollow\">proxy_pass</a> directive should not be used in the same location.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the content_by_lua_block directive instead.","Acts as a \"content handler\" and executes Lua code string specified in <lua-script-str> for every request.\nThe Lua code may make API calls and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).","Do not use this directive and other content handler directives in the same location. For example, this directive and the proxy_pass directive should not be used in the same location."],"<table ><tr><th>Syntax:</th><td><code><strong>content_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>content_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>location</code>,<code>location if</code></td></tr></table>"],
[4,"content_by_lua_block","Similar to the content_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#content_by_lua\">content_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n content_by_lua_block {\n     ngx.say(&quot;I need no extra escaping here, for example: \\r\\nblah&quot;)\n }\n\"><pre> <span class=\"pl-k\">content_by_lua_block</span> {\n     ngx.say(\"<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the content_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," content_by_lua_block {\n     ngx.say(\"I need no extra escaping here, for example: \\r\\nblah\")\n }","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>content_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>content_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>location</code>,<code>location if</code></td></tr></table>"],
[4,"content_by_lua_file","Equivalent to content_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#content_by_lua\">content_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by\nswitching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p dir=\"auto\">Nginx variables are supported in the file path for dynamic dispatch, for example:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n # CAUTION: contents in nginx var must be carefully filtered,\n # otherwise there'll be great security risk!\n location ~ ^/app/([-_a-zA-Z0-9/]+) {\n     set $path $1;\n     content_by_lua_file /path/to/lua/app/root/$path.lua;\n }\n\"><pre> <span class=\"pl-c\"># CAUTION: contents in nginx var must be carefully filtered,</span>\n <span class=\"pl-c\"># otherwise there'll be great security risk!</span>\n <span class=\"pl-k\">location</span> ~ <span class=\"pl-sr\">^/app/([-_a-zA-Z0-9/]+) </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$path</span> <span class=\"pl-smi\">$1</span>;\n     <span class=\"pl-k\">content_by_lua_file</span> /path/to/lua/app/root/<span class=\"pl-smi\">$path</span>.lua;\n }</pre></div><p dir=\"auto\">But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.</p>",["Equivalent to content_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","Nginx variables can be used in the <path-to-lua-script-file> string to provide flexibility. This however carries some risks and is not ordinarily recommended.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by\nswitching lua_code_cache off in nginx.conf to avoid reloading Nginx.","Nginx variables are supported in the file path for dynamic dispatch, for example:"," # CAUTION: contents in nginx var must be carefully filtered,\n # otherwise there'll be great security risk!\n location ~ ^/app/([-_a-zA-Z0-9/]+) {\n     set $path $1;\n     content_by_lua_file /path/to/lua/app/root/$path.lua;\n }","But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components."],"<table ><tr><th>Syntax:</th><td><code><strong>content_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>content_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>location</code>,<code>location if</code></td></tr></table>"],
[4,"rewrite_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the rewrite_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#rewrite_by_lua_block\">rewrite_by_lua_block</a> directive instead.</p><p dir=\"auto\">Acts as a rewrite phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.\nThe Lua code may make <a href=\"#nginx-api-for-lua\">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p dir=\"auto\">Note that this handler always runs <em>after</em> the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>. So the following will work as expected:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location /foo {\n     set $a 12; # create and initialize $a\n     set $b &quot;&quot;; # create and initialize $b\n     rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';\n     echo &quot;res = $b&quot;;\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$a</span> <span class=\"pl-s\">12</span>; <span class=\"pl-c\"># create and initialize $a</span>\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$b</span> <span class=\"pl-s\">\"\"</span>; <span class=\"pl-c\"># create and initialize $b</span>\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">'ngx.var.b = tonumber(ngx.var.a) + 1'</span>;\n     <span class=\"pl-k\">echo</span> <span class=\"pl-s\">\"res = <span class=\"pl-smi\">$b</span>\"</span>;\n }</pre></div><p dir=\"auto\">because <code>set $a 12</code> and <code>set $b \"\"</code> run <em>before</em> <a href=\"#rewrite_by_lua\">rewrite_by_lua</a>.</p><p dir=\"auto\">On the other hand, the following will not work as expected:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n ?  location /foo {\n ?      set $a 12; # create and initialize $a\n ?      set $b ''; # create and initialize $b\n ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';\n ?      if ($b = '13') {\n ?         rewrite ^ /bar redirect;\n ?         break;\n ?      }\n ?\n ?      echo &quot;res = $b&quot;;\n ?  }\n\"><pre> ?  <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n ?      <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$a</span> <span class=\"pl-s\">12</span>; <span class=\"pl-c\"># create and initialize $a</span>\n ?      <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$b</span> <span class=\"pl-s\">''</span>; <span class=\"pl-c\"># create and initialize $b</span>\n ?      <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">'ngx.var.b = tonumber(ngx.var.a) + 1'</span>;\n ?      <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">$b</span> = <span class=\"pl-s\">'13'</span>) {\n ?         <span class=\"pl-k\">rewrite</span> <span class=\"pl-sr\">^ </span>/bar redirect;\n ?         <span class=\"pl-c1\">break</span>;\n ?      }\n ?\n ?      <span class=\"pl-k\">echo</span> <span class=\"pl-s\">\"res = <span class=\"pl-smi\">$b</span>\"</span>;\n ?  }</pre></div><p dir=\"auto\">because <code>if</code> runs <em>before</em> <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> even if it is placed after <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> in the config.</p><p dir=\"auto\">The right way of doing this is as follows:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location /foo {\n     set $a 12; # create and initialize $a\n     set $b ''; # create and initialize $b\n     rewrite_by_lua '\n         ngx.var.b = tonumber(ngx.var.a) + 1\n         if tonumber(ngx.var.b) == 13 then\n             return ngx.redirect(&quot;/bar&quot;)\n         end\n     ';\n\n     echo &quot;res = $b&quot;;\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$a</span> <span class=\"pl-s\">12</span>; <span class=\"pl-c\"># create and initialize $a</span>\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$b</span> <span class=\"pl-s\">''</span>; <span class=\"pl-c\"># create and initialize $b</span>\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">         ngx.var.b = tonumber(ngx.var.a) + 1</span>\n<span class=\"pl-s\">         if tonumber(ngx.var.b) == 13 then</span>\n<span class=\"pl-s\">             return ngx.redirect(\"/bar\")</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\">     '</span>;\n\n     <span class=\"pl-k\">echo</span> <span class=\"pl-s\">\"res = <span class=\"pl-smi\">$b</span>\"</span>;\n }</pre></div><p dir=\"auto\">Note that the <a href=\"http://www.grid.net.ru/nginx/eval.en.html\" rel=\"nofollow\">ngx_eval</a> module can be approximated by using <a href=\"#rewrite_by_lua\">rewrite_by_lua</a>. For example,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location / {\n     eval $res {\n         proxy_pass http://foo.com/check-spam;\n     }\n\n     if ($res = 'spam') {\n         rewrite ^ /terms-of-use.html redirect;\n     }\n\n     fastcgi_pass ...;\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">eval</span> <span class=\"pl-smi\">$res</span> {\n         <span class=\"pl-k\">proxy_pass</span> http://foo.com/check-spam;\n     }\n\n     <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">$res</span> = <span class=\"pl-s\">'spam'</span>) {\n         <span class=\"pl-k\">rewrite</span> <span class=\"pl-sr\">^ </span>/terms-of-use.html redirect;\n     }\n\n     <span class=\"pl-k\">fastcgi_pass</span> ...;\n }</pre></div><p dir=\"auto\">can be implemented in ngx_lua as:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location = /check-spam {\n     internal;\n     proxy_pass http://foo.com/check-spam;\n }\n\n location / {\n     rewrite_by_lua '\n         local res = ngx.location.capture(&quot;/check-spam&quot;)\n         if res.body == &quot;spam&quot; then\n             return ngx.redirect(&quot;/terms-of-use.html&quot;)\n         end\n     ';\n\n     fastcgi_pass ...;\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">= /check-spam </span>{\n     <span class=\"pl-k\">internal</span>;\n     <span class=\"pl-k\">proxy_pass</span> http://foo.com/check-spam;\n }\n\n <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">         local res = ngx.location.capture(\"/check-spam\")</span>\n<span class=\"pl-s\">         if res.body == \"spam\" then</span>\n<span class=\"pl-s\">             return ngx.redirect(\"/terms-of-use.html\")</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\">     '</span>;\n\n     <span class=\"pl-k\">fastcgi_pass</span> ...;\n }</pre></div><p dir=\"auto\">Just as any other rewrite phase handlers, <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> also runs in subrequests.</p><p dir=\"auto\">Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> handler, the Nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> handler, call <a href=\"#ngxexit\">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p dir=\"auto\">If the <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>'s <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite\" rel=\"nofollow\">rewrite</a> directive is used to change the URI and initiate location re-lookups (internal redirections), then any <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> or <a href=\"#rewrite_by_lua_file\">rewrite_by_lua_file</a> code sequences within the current location will not be executed. For example,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location /foo {\n     rewrite ^ /bar;\n     rewrite_by_lua 'ngx.exit(503)';\n }\n location /bar {\n     ...\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">rewrite</span> <span class=\"pl-sr\">^ </span>/bar;\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">'ngx.exit(503)'</span>;\n }\n <span class=\"pl-k\">location</span> <span class=\"pl-en\">/bar </span>{\n     ...\n }</pre></div><p dir=\"auto\">Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the <code>rewrite_by_lua</code> code will be executed.</p><p dir=\"auto\">The <code>rewrite_by_lua</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href=\"#rewrite_by_lua_no_postpone\">rewrite_by_lua_no_postpone</a> is turned on.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the rewrite_by_lua_block directive instead.","Acts as a rewrite phase handler and executes Lua code string specified in <lua-script-str> for every request.\nThe Lua code may make API calls and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).","Note that this handler always runs after the standard ngx_http_rewrite_module. So the following will work as expected:"," location /foo {\n     set $a 12; # create and initialize $a\n     set $b \"\"; # create and initialize $b\n     rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';\n     echo \"res = $b\";\n }","because set $a 12 and set $b \"\" run before rewrite_by_lua.","On the other hand, the following will not work as expected:"," ?  location /foo {\n ?      set $a 12; # create and initialize $a\n ?      set $b ''; # create and initialize $b\n ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';\n ?      if ($b = '13') {\n ?         rewrite ^ /bar redirect;\n ?         break;\n ?      }\n ?\n ?      echo \"res = $b\";\n ?  }","because if runs before rewrite_by_lua even if it is placed after rewrite_by_lua in the config.","The right way of doing this is as follows:"," location /foo {\n     set $a 12; # create and initialize $a\n     set $b ''; # create and initialize $b\n     rewrite_by_lua '\n         ngx.var.b = tonumber(ngx.var.a) + 1\n         if tonumber(ngx.var.b) == 13 then\n             return ngx.redirect(\"/bar\")\n         end\n     ';\n\n     echo \"res = $b\";\n }","Note that the ngx_eval module can be approximated by using rewrite_by_lua. For example,"," location / {\n     eval $res {\n         proxy_pass http://foo.com/check-spam;\n     }\n\n     if ($res = 'spam') {\n         rewrite ^ /terms-of-use.html redirect;\n     }\n\n     fastcgi_pass ...;\n }","can be implemented in ngx_lua as:"," location = /check-spam {\n     internal;\n     proxy_pass http://foo.com/check-spam;\n }\n\n location / {\n     rewrite_by_lua '\n         local res = ngx.location.capture(\"/check-spam\")\n         if res.body == \"spam\" then\n             return ngx.redirect(\"/terms-of-use.html\")\n         end\n     ';\n\n     fastcgi_pass ...;\n }","Just as any other rewrite phase handlers, rewrite_by_lua also runs in subrequests.","Note that when calling ngx.exit(ngx.OK) within a rewrite_by_lua handler, the Nginx request processing control flow will still continue to the content handler. To terminate the current request from within a rewrite_by_lua handler, call ngx.exit with status >= 200 (ngx.HTTP_OK) and status < 300 (ngx.HTTP_SPECIAL_RESPONSE) for successful quits and ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) (or its friends) for failures.","If the ngx_http_rewrite_module's rewrite directive is used to change the URI and initiate location re-lookups (internal redirections), then any rewrite_by_lua or rewrite_by_lua_file code sequences within the current location will not be executed. For example,"," location /foo {\n     rewrite ^ /bar;\n     rewrite_by_lua 'ngx.exit(503)';\n }\n location /bar {\n     ...\n }","Here the Lua code ngx.exit(503) will never run. This will be the case if rewrite ^ /bar last is used as this will similarly initiate an internal redirection. If the break modifier is used instead, there will be no internal redirection and the rewrite_by_lua code will be executed.","The rewrite_by_lua code will always run at the end of the rewrite request-processing phase unless rewrite_by_lua_no_postpone is turned on."],"<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"rewrite_by_lua_block","Similar to the rewrite_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n rewrite_by_lua_block {\n     do_something(&quot;hello, world!\\nhiya\\n&quot;)\n }\n\"><pre> <span class=\"pl-k\">rewrite_by_lua_block</span> {\n     do_something(\"hello, world!\\nhiya\\n\")\n }</pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the rewrite_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," rewrite_by_lua_block {\n     do_something(\"hello, world!\\nhiya\\n\")\n }","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"rewrite_by_lua_file","Equivalent to rewrite_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#rewrite_by_lua\">rewrite_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p dir=\"auto\">The <code>rewrite_by_lua_file</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href=\"#rewrite_by_lua_no_postpone\">rewrite_by_lua_no_postpone</a> is turned on.</p><p dir=\"auto\">Nginx variables are supported in the file path for dynamic dispatch just as in <a href=\"#content_by_lua_file\">content_by_lua_file</a>.</p>",["Equivalent to rewrite_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","Nginx variables can be used in the <path-to-lua-script-file> string to provide flexibility. This however carries some risks and is not ordinarily recommended.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching lua_code_cache off in nginx.conf to avoid reloading Nginx.","The rewrite_by_lua_file code will always run at the end of the rewrite request-processing phase unless rewrite_by_lua_no_postpone is turned on.","Nginx variables are supported in the file path for dynamic dispatch just as in content_by_lua_file."],"<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"access_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the access_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#access_by_lua_block\">access_by_lua_block</a> directive instead.</p><p dir=\"auto\">Acts as an access phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.\nThe Lua code may make <a href=\"#nginx-api-for-lua\">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p dir=\"auto\">Note that this handler always runs <em>after</em> the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_access_module.html\" rel=\"nofollow\">ngx_http_access_module</a>. So the following will work as expected:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location / {\n     deny    192.168.1.1;\n     allow   192.168.1.0/24;\n     allow   10.1.1.0/16;\n     deny    all;\n\n     access_by_lua '\n         local res = ngx.location.capture(&quot;/mysql&quot;, { ... })\n         ...\n     ';\n\n     # proxy_pass/fastcgi_pass/...\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">deny</span>    <span class=\"pl-s\">192.168.1.1</span>;\n     <span class=\"pl-k\">allow</span>   <span class=\"pl-s\">192.168.1.0</span><span class=\"pl-c1\">/24</span>;\n     <span class=\"pl-k\">allow</span>   <span class=\"pl-s\">10.1.1.0</span><span class=\"pl-c1\">/16</span>;\n     <span class=\"pl-k\">deny</span>   <span class=\"pl-c1\"> all</span>;\n\n     <span class=\"pl-k\">access_by_lua</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">         local res = ngx.location.capture(\"/mysql\", { ... })</span>\n<span class=\"pl-s\">         ...</span>\n<span class=\"pl-s\">     '</span>;\n\n     <span class=\"pl-c\"># proxy_pass/fastcgi_pass/...</span>\n }</pre></div><p dir=\"auto\">That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by <a href=\"#access_by_lua\">access_by_lua</a>.</p><p dir=\"auto\">Note that the <a href=\"http://mdounin.ru/hg/ngx_http_auth_request_module/\" rel=\"nofollow\">ngx_auth_request</a> module can be approximated by using <a href=\"#access_by_lua\">access_by_lua</a>:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location / {\n     auth_request /auth;\n\n     # proxy_pass/fastcgi_pass/postgres_pass/...\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">auth_request</span> /auth;\n\n     <span class=\"pl-c\"># proxy_pass/fastcgi_pass/postgres_pass/...</span>\n }</pre></div><p dir=\"auto\">can be implemented in ngx_lua as:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location / {\n     access_by_lua '\n         local res = ngx.location.capture(&quot;/auth&quot;)\n\n         if res.status == ngx.HTTP_OK then\n             return\n         end\n\n         if res.status == ngx.HTTP_FORBIDDEN then\n             ngx.exit(res.status)\n         end\n\n         ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n     ';\n\n     # proxy_pass/fastcgi_pass/postgres_pass/...\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">access_by_lua</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">         local res = ngx.location.capture(\"/auth\")</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         if res.status == ngx.HTTP_OK then</span>\n<span class=\"pl-s\">             return</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         if res.status == ngx.HTTP_FORBIDDEN then</span>\n<span class=\"pl-s\">             ngx.exit(res.status)</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</span>\n<span class=\"pl-s\">     '</span>;\n\n     <span class=\"pl-c\"># proxy_pass/fastcgi_pass/postgres_pass/...</span>\n }</pre></div><p dir=\"auto\">As with other access phase handlers, <a href=\"#access_by_lua\">access_by_lua</a> will <em>not</em> run in subrequests.</p><p dir=\"auto\">Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href=\"#access_by_lua\">access_by_lua</a> handler, the Nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href=\"#access_by_lua\">access_by_lua</a> handler, call <a href=\"#ngxexit\">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p dir=\"auto\">Starting from the <code>v0.9.20</code> release, you can use the <a href=\"#access_by_lua_no_postpone\">access_by_lua_no_postpone</a>\ndirective to control when to run this handler inside the \"access\" request-processing phase\nof Nginx.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the access_by_lua_block directive instead.","Acts as an access phase handler and executes Lua code string specified in <lua-script-str> for every request.\nThe Lua code may make API calls and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).","Note that this handler always runs after the standard ngx_http_access_module. So the following will work as expected:"," location / {\n     deny    192.168.1.1;\n     allow   192.168.1.0/24;\n     allow   10.1.1.0/16;\n     deny    all;\n\n     access_by_lua '\n         local res = ngx.location.capture(\"/mysql\", { ... })\n         ...\n     ';\n\n     # proxy_pass/fastcgi_pass/...\n }","That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by access_by_lua.","Note that the ngx_auth_request module can be approximated by using access_by_lua:"," location / {\n     auth_request /auth;\n\n     # proxy_pass/fastcgi_pass/postgres_pass/...\n }","can be implemented in ngx_lua as:"," location / {\n     access_by_lua '\n         local res = ngx.location.capture(\"/auth\")\n\n         if res.status == ngx.HTTP_OK then\n             return\n         end\n\n         if res.status == ngx.HTTP_FORBIDDEN then\n             ngx.exit(res.status)\n         end\n\n         ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)\n     ';\n\n     # proxy_pass/fastcgi_pass/postgres_pass/...\n }","As with other access phase handlers, access_by_lua will not run in subrequests.","Note that when calling ngx.exit(ngx.OK) within a access_by_lua handler, the Nginx request processing control flow will still continue to the content handler. To terminate the current request from within a access_by_lua handler, call ngx.exit with status >= 200 (ngx.HTTP_OK) and status < 300 (ngx.HTTP_SPECIAL_RESPONSE) for successful quits and ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR) (or its friends) for failures.","Starting from the v0.9.20 release, you can use the access_by_lua_no_postpone\ndirective to control when to run this handler inside the \"access\" request-processing phase\nof Nginx."],"<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"access_by_lua_block","Similar to the access_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#access_by_lua\">access_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n access_by_lua_block {\n     do_something(&quot;hello, world!\\nhiya\\n&quot;)\n }\n\"><pre> <span class=\"pl-k\">access_by_lua_block</span> {\n     do_something(\"hello, world!\\nhiya\\n\")\n }</pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the access_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," access_by_lua_block {\n     do_something(\"hello, world!\\nhiya\\n\")\n }","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"access_by_lua_file","Equivalent to access_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#access_by_lua\">access_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by switching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.</p><p dir=\"auto\">Nginx variables are supported in the file path for dynamic dispatch just as in <a href=\"#content_by_lua_file\">content_by_lua_file</a>.</p>",["Equivalent to access_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","Nginx variables can be used in the <path-to-lua-script-file> string to provide flexibility. This however carries some risks and is not ordinarily recommended.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by switching lua_code_cache off in nginx.conf to avoid repeatedly reloading Nginx.","Nginx variables are supported in the file path for dynamic dispatch just as in content_by_lua_file."],"<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"header_filter_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the header_filter_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#header_filter_by_lua_block\">header_filter_by_lua_block</a> directive instead.</p><p dir=\"auto\">Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output header filter.</p><p dir=\"auto\">Note that the following API functions are currently disabled within this context:</p><ul dir=\"auto\">\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxredirect\">ngx.redirect</a> and <a href=\"#ngxexec\">ngx.exec</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n</ul><p dir=\"auto\">Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location / {\n     proxy_pass http://mybackend;\n     header_filter_by_lua 'ngx.header.Foo = &quot;blah&quot;';\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">proxy_pass</span> http://mybackend;\n     <span class=\"pl-k\">header_filter_by_lua</span> <span class=\"pl-s\">'ngx.header.Foo = \"blah\"'</span>;\n }</pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.2.1rc20</code> release.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the header_filter_by_lua_block directive instead.","Uses Lua code specified in <lua-script-str> to define an output header filter.","Note that the following API functions are currently disabled within this context:","\nOutput API functions (e.g., ngx.say and ngx.send_headers)\nControl API functions (e.g., ngx.redirect and ngx.exec)\nSubrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi)\nCosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).\n","Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:"," location / {\n     proxy_pass http://mybackend;\n     header_filter_by_lua 'ngx.header.Foo = \"blah\"';\n }","This directive was first introduced in the v0.2.1rc20 release."],"<table ><tr><th>Syntax:</th><td><code><strong>header_filter_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>header_filter_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"header_filter_by_lua_block","Similar to the header_filter_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#header_filter_by_lua\">header_filter_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n header_filter_by_lua_block {\n     ngx.header[&quot;content-length&quot;] = nil\n }\n\"><pre> <span class=\"pl-k\">header_filter_by_lua_block</span> {\n     ngx.header[\"content-length\"] = <span class=\"pl-k\">nil</span>\n }</pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the header_filter_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," header_filter_by_lua_block {\n     ngx.header[\"content-length\"] = nil\n }","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>header_filter_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>header_filter_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"header_filter_by_lua_file","Equivalent to header_filter_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#header_filter_by_lua\">header_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.2.1rc20</code> release.</p>",["Equivalent to header_filter_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.2.1rc20 release."],"<table ><tr><th>Syntax:</th><td><code><strong>header_filter_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>header_filter_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"body_filter_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the body_filter_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#body_filter_by_lua_block\">body_filter_by_lua_block</a> directive instead.</p><p dir=\"auto\">Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output body filter.</p><p dir=\"auto\">The input data chunk is passed via <a href=\"#ngxarg\">ngx.arg</a>[1] (as a Lua string value) and the \"eof\" flag indicating the end of the response body data stream is passed via <a href=\"#ngxarg\">ngx.arg</a>[2] (as a Lua boolean value).</p><p dir=\"auto\">Behind the scene, the \"eof\" flag is just the <code>last_buf</code> (for main requests) or <code>last_in_chain</code> (for subrequests) flag of the Nginx chain link buffers. (Before the <code>v0.7.14</code> release, the \"eof\" flag does not work at all in subrequests.)</p><p dir=\"auto\">The output data stream can be aborted immediately by running the following Lua statement:</p><div class=\"highlight highlight-source-lua position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n return ngx.ERROR\n\"><pre> <span class=\"pl-k\">return</span> ngx.<span class=\"pl-smi\">ERROR</span></pre></div><p dir=\"auto\">This will truncate the response body and usually result in incomplete and also invalid responses.</p><p dir=\"auto\">The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding <a href=\"#ngxarg\">ngx.arg</a>[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location / {\n     proxy_pass http://mybackend;\n     body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">proxy_pass</span> http://mybackend;\n     <span class=\"pl-k\">body_filter_by_lua</span> <span class=\"pl-s\">'ngx.arg[1] = string.upper(ngx.arg[1])'</span>;\n }</pre></div><p dir=\"auto\">When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p><p dir=\"auto\">Likewise, new \"eof\" flag can also be specified by setting a boolean value to <a href=\"#ngxarg\">ngx.arg</a>[2]. For example,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location /t {\n     echo hello world;\n     echo hiya globe;\n\n     body_filter_by_lua '\n         local chunk = ngx.arg[1]\n         if string.match(chunk, &quot;hello&quot;) then\n             ngx.arg[2] = true  -- new eof\n             return\n         end\n\n         -- just throw away any remaining chunk data\n         ngx.arg[1] = nil\n     ';\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/t </span>{\n     <span class=\"pl-k\">echo</span> hello world;\n     <span class=\"pl-k\">echo</span> hiya globe;\n\n     <span class=\"pl-k\">body_filter_by_lua</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">         local chunk = ngx.arg[1]</span>\n<span class=\"pl-s\">         if string.match(chunk, \"hello\") then</span>\n<span class=\"pl-s\">             ngx.arg[2] = true  -- new eof</span>\n<span class=\"pl-s\">             return</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         -- just throw away any remaining chunk data</span>\n<span class=\"pl-s\">         ngx.arg[1] = nil</span>\n<span class=\"pl-s\">     '</span>;\n }</pre></div><p dir=\"auto\">Then <code>GET /t</code> will just return the output</p><div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"hello world\n\"><pre><code>hello world\n</code></pre></div><p dir=\"auto\">That is, when the body filter sees a chunk containing the word \"hello\", then it will set the \"eof\" flag to true immediately, resulting in truncated but still valid responses.</p><p dir=\"auto\">When the Lua code may change the length of the response body, then it is required to always clear out the <code>Content-Length</code> response header (if any) in a header filter to enforce streaming output, as in</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n location /foo {\n     # fastcgi_pass/proxy_pass/...\n\n     header_filter_by_lua_block { ngx.header.content_length = nil }\n     body_filter_by_lua 'ngx.arg[1] = string.len(ngx.arg[1]) .. &quot;\\\\n&quot;';\n }\n\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-c\"># fastcgi_pass/proxy_pass/...</span>\n\n     <span class=\"pl-k\">header_filter_by_lua_block</span> { ngx.header.content_length = nil }\n     <span class=\"pl-k\">body_filter_by_lua</span> <span class=\"pl-s\">'ngx.arg[1] = string.len(ngx.arg[1]) .. \"\\\\n\"'</span>;\n }</pre></div><p dir=\"auto\">Note that the following API functions are currently disabled within this context due to the limitations in Nginx output filter's current implementation:</p><ul dir=\"auto\">\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxexit\">ngx.exit</a> and <a href=\"#ngxexec\">ngx.exec</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n</ul><p dir=\"auto\">Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the body_filter_by_lua_block directive instead.","Uses Lua code specified in <lua-script-str> to define an output body filter.","The input data chunk is passed via ngx.arg[1] (as a Lua string value) and the \"eof\" flag indicating the end of the response body data stream is passed via ngx.arg[2] (as a Lua boolean value).","Behind the scene, the \"eof\" flag is just the last_buf (for main requests) or last_in_chain (for subrequests) flag of the Nginx chain link buffers. (Before the v0.7.14 release, the \"eof\" flag does not work at all in subrequests.)","The output data stream can be aborted immediately by running the following Lua statement:"," return ngx.ERROR","This will truncate the response body and usually result in incomplete and also invalid responses.","The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding ngx.arg[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:"," location / {\n     proxy_pass http://mybackend;\n     body_filter_by_lua 'ngx.arg[1] = string.upper(ngx.arg[1])';\n }","When setting nil or an empty Lua string value to ngx.arg[1], no data chunk will be passed to the downstream Nginx output filters at all.","Likewise, new \"eof\" flag can also be specified by setting a boolean value to ngx.arg[2]. For example,"," location /t {\n     echo hello world;\n     echo hiya globe;\n\n     body_filter_by_lua '\n         local chunk = ngx.arg[1]\n         if string.match(chunk, \"hello\") then\n             ngx.arg[2] = true  -- new eof\n             return\n         end\n\n         -- just throw away any remaining chunk data\n         ngx.arg[1] = nil\n     ';\n }","Then GET /t will just return the output","hello world\n","That is, when the body filter sees a chunk containing the word \"hello\", then it will set the \"eof\" flag to true immediately, resulting in truncated but still valid responses.","When the Lua code may change the length of the response body, then it is required to always clear out the Content-Length response header (if any) in a header filter to enforce streaming output, as in"," location /foo {\n     # fastcgi_pass/proxy_pass/...\n\n     header_filter_by_lua_block { ngx.header.content_length = nil }\n     body_filter_by_lua 'ngx.arg[1] = string.len(ngx.arg[1]) .. \"\\\\n\"';\n }","Note that the following API functions are currently disabled within this context due to the limitations in Nginx output filter's current implementation:","\nOutput API functions (e.g., ngx.say and ngx.send_headers)\nControl API functions (e.g., ngx.exit and ngx.exec)\nSubrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi)\nCosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).\n","Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.","This directive was first introduced in the v0.5.0rc32 release."],"<table ><tr><th>Syntax:</th><td><code><strong>body_filter_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>body_filter_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"body_filter_by_lua_block","Similar to the body_filter_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#body_filter_by_lua\">body_filter_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n body_filter_by_lua_block {\n     local data, eof = ngx.arg[1], ngx.arg[2]\n }\n\"><pre> <span class=\"pl-k\">body_filter_by_lua_block</span> {\n     <span class=\"pl-k\">local</span> data, eof = ngx.arg[1], ngx.arg[2]\n }</pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the body_filter_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," body_filter_by_lua_block {\n     local data, eof = ngx.arg[1], ngx.arg[2]\n }","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>body_filter_by_lua_block { lua-script-str }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>body_filter_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"body_filter_by_lua_file","Equivalent to body_filter_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#body_filter_by_lua\">body_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>",["Equivalent to body_filter_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.5.0rc32 release."],"<table ><tr><th>Syntax:</th><td><code><strong>body_filter_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>body_filter_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"log_by_lua","NOTE Use of this directive is discouraged following the v0.9.17 release. Use the log_by_lua_block directive instead.","<p dir=\"auto\"><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#log_by_lua_block\">log_by_lua_block</a> directive instead.</p><p dir=\"auto\">Runs the Lua source code inlined as the <code>&lt;lua-script-str&gt;</code> at the <code>log</code> request processing phase. This does not replace the current access logs, but runs before.</p><p dir=\"auto\">Note that the following API functions are currently disabled within this context:</p><ul dir=\"auto\">\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxexit\">ngx.exit</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n</ul><p dir=\"auto\">Here is an example of gathering average data for <a href=\"http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time\" rel=\"nofollow\">$upstream_response_time</a>:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n lua_shared_dict log_dict 5M;\n\n server {\n     location / {\n         proxy_pass http://mybackend;\n\n         log_by_lua '\n             local log_dict = ngx.shared.log_dict\n             local upstream_time = tonumber(ngx.var.upstream_response_time)\n\n             local sum = log_dict:get(&quot;upstream_time-sum&quot;) or 0\n             sum = sum + upstream_time\n             log_dict:set(&quot;upstream_time-sum&quot;, sum)\n\n             local newval, err = log_dict:incr(&quot;upstream_time-nb&quot;, 1)\n             if not newval and err == &quot;not found&quot; then\n                 log_dict:add(&quot;upstream_time-nb&quot;, 0)\n                 log_dict:incr(&quot;upstream_time-nb&quot;, 1)\n             end\n         ';\n     }\n\n     location = /status {\n         content_by_lua_block {\n             local log_dict = ngx.shared.log_dict\n             local sum = log_dict:get(&quot;upstream_time-sum&quot;)\n             local nb = log_dict:get(&quot;upstream_time-nb&quot;)\n\n             if nb and sum then\n                 ngx.say(&quot;average upstream response time: &quot;, sum / nb,\n                         &quot; (&quot;, nb, &quot; reqs)&quot;)\n             else\n                 ngx.say(&quot;no data yet&quot;)\n             end\n         }\n     }\n }\n\"><pre> <span class=\"pl-k\">lua_shared_dict</span> log_dict <span class=\"pl-c1\">5M</span>;\n\n <span class=\"pl-k\">server</span> {\n     <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n         <span class=\"pl-k\">proxy_pass</span> http://mybackend;\n\n         <span class=\"pl-k\">log_by_lua</span> <span class=\"pl-s\">'</span>\n<span class=\"pl-s\">             local log_dict = ngx.shared.log_dict</span>\n<span class=\"pl-s\">             local upstream_time = tonumber(ngx.var.upstream_response_time)</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">             local sum = log_dict:get(\"upstream_time-sum\") or 0</span>\n<span class=\"pl-s\">             sum = sum + upstream_time</span>\n<span class=\"pl-s\">             log_dict:set(\"upstream_time-sum\", sum)</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">             local newval, err = log_dict:incr(\"upstream_time-nb\", 1)</span>\n<span class=\"pl-s\">             if not newval and err == \"not found\" then</span>\n<span class=\"pl-s\">                 log_dict:add(\"upstream_time-nb\", 0)</span>\n<span class=\"pl-s\">                 log_dict:incr(\"upstream_time-nb\", 1)</span>\n<span class=\"pl-s\">             end</span>\n<span class=\"pl-s\">         '</span>;\n     }\n\n     <span class=\"pl-k\">location</span> <span class=\"pl-en\">= /status </span>{\n         <span class=\"pl-k\">content_by_lua_block</span> {\n             <span class=\"pl-k\">local</span> log_dict = ngx.shared.log_dict\n             <span class=\"pl-k\">local</span> sum = log_dict:get(<span class=\"pl-s\">\"upstream_time-sum\"</span>)\n             <span class=\"pl-k\">local</span> nb = log_dict:get(<span class=\"pl-s\">\"upstream_time-nb\"</span>)\n\n             <span class=\"pl-k\">if</span> nb and sum then\n                 ngx.say(\"<span class=\"pl-k\">average</span> upstream response time: <span class=\"pl-s\">\", sum / nb,</span>\n<span class=\"pl-s\">                         \"</span> (<span class=\"pl-s\">\", nb, \"</span> reqs)<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\">             else</span>\n<span class=\"pl-s\">                 ngx.say(\"</span>no data yet<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\">             end</span>\n<span class=\"pl-s\">         }</span>\n<span class=\"pl-s\">     }</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc31</code> release.</p>",["NOTE Use of this directive is discouraged following the v0.9.17 release. Use the log_by_lua_block directive instead.","Runs the Lua source code inlined as the <lua-script-str> at the log request processing phase. This does not replace the current access logs, but runs before.","Note that the following API functions are currently disabled within this context:","\nOutput API functions (e.g., ngx.say and ngx.send_headers)\nControl API functions (e.g., ngx.exit)\nSubrequest API functions (e.g., ngx.location.capture and ngx.location.capture_multi)\nCosocket API functions (e.g., ngx.socket.tcp and ngx.req.socket).\n","Here is an example of gathering average data for $upstream_response_time:"," lua_shared_dict log_dict 5M;\n\n server {\n     location / {\n         proxy_pass http://mybackend;\n\n         log_by_lua '\n             local log_dict = ngx.shared.log_dict\n             local upstream_time = tonumber(ngx.var.upstream_response_time)\n\n             local sum = log_dict:get(\"upstream_time-sum\") or 0\n             sum = sum + upstream_time\n             log_dict:set(\"upstream_time-sum\", sum)\n\n             local newval, err = log_dict:incr(\"upstream_time-nb\", 1)\n             if not newval and err == \"not found\" then\n                 log_dict:add(\"upstream_time-nb\", 0)\n                 log_dict:incr(\"upstream_time-nb\", 1)\n             end\n         ';\n     }\n\n     location = /status {\n         content_by_lua_block {\n             local log_dict = ngx.shared.log_dict\n             local sum = log_dict:get(\"upstream_time-sum\")\n             local nb = log_dict:get(\"upstream_time-nb\")\n\n             if nb and sum then\n                 ngx.say(\"average upstream response time: \", sum / nb,\n                         \" (\", nb, \" reqs)\")\n             else\n                 ngx.say(\"no data yet\")\n             end\n         }\n     }\n }","This directive was first introduced in the v0.5.0rc31 release."],"<table ><tr><th>Syntax:</th><td><code><strong>log_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>log_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"log_by_lua_block","Similar to the log_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","<p dir=\"auto\">Similar to the <a href=\"#log_by_lua\">log_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an Nginx string literal (which requires\nspecial character escaping).</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n log_by_lua_block {\n     print(&quot;I need no extra escaping here, for example: \\r\\nblah&quot;)\n }\n\"><pre> <span class=\"pl-k\">log_by_lua_block</span> {\n     print(\"<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.9.17</code> release.</p>",["Similar to the log_by_lua directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces ({}) instead of in an Nginx string literal (which requires\nspecial character escaping).","For instance,"," log_by_lua_block {\n     print(\"I need no extra escaping here, for example: \\r\\nblah\")\n }","This directive was first introduced in the v0.9.17 release."],"<table ><tr><th>Syntax:</th><td><code><strong>log_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>log_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"log_by_lua_file","Equivalent to log_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#log_by_lua\">log_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc31</code> release.</p>",["Equivalent to log_by_lua, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.5.0rc31 release."],"<table ><tr><th>Syntax:</th><td><code><strong>log_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>log_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"balancer_by_lua_block","This directive runs Lua code as an upstream balancer for any upstream entities defined\nby the upstream {} configuration block.","<p dir=\"auto\">This directive runs Lua code as an upstream balancer for any upstream entities defined\nby the <code>upstream {}</code> configuration block.</p><p dir=\"auto\">For instance,</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n upstream foo {\n     server 127.0.0.1;\n     balancer_by_lua_block {\n         -- use Lua to do something interesting here\n         -- as a dynamic balancer\n     }\n }\n\n server {\n     location / {\n         proxy_pass http://foo;\n     }\n }\n\"><pre> <span class=\"pl-k\">upstream</span> <span class=\"pl-en\">foo </span>{\n     <span class=\"pl-k\">server</span> <span class=\"pl-s\">127.0.0.1</span>;\n     <span class=\"pl-k\">balancer_by_lua_block</span> {\n         -- <span class=\"pl-k\">use</span> Lua to do something interesting here\n         -- as <span class=\"pl-s\">a</span> dynamic balancer\n     }\n }\n\n server {\n     location / {\n         proxy_pass http://foo;\n     }\n }</pre></div><p dir=\"auto\">The resulting Lua load balancer can work with any existing Nginx upstream modules\nlike <a href=\"https://nginx.org/en/docs/http/ngx_http_proxy_module.html\" rel=\"nofollow\">ngx_proxy</a> and\n<a href=\"https://nginx.org/en/docs/http/ngx_http_fastcgi_module.html\" rel=\"nofollow\">ngx_fastcgi</a>.</p><p dir=\"auto\">Also, the Lua load balancer can work with the standard upstream connection pool mechanism,\ni.e., the standard <a href=\"https://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive\" rel=\"nofollow\">keepalive</a> directive.\nJust ensure that the <a href=\"https://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive\" rel=\"nofollow\">keepalive</a> directive\nis used <em>after</em> this <code>balancer_by_lua_block</code> directive in a single <code>upstream {}</code> configuration block.</p><p dir=\"auto\">The Lua load balancer can totally ignore the list of servers defined in the <code>upstream {}</code> block\nand select peer from a completely dynamic server list (even changing per request) via the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md\">ngx.balancer</a> module\nfrom the <a href=\"https://github.com/openresty/lua-resty-core\">lua-resty-core</a> library.</p><p dir=\"auto\">The Lua code handler registered by this directive might get called more than once in a single\ndownstream request when the Nginx upstream mechanism retries the request on conditions\nspecified by directives like the <a href=\"https://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream\" rel=\"nofollow\">proxy_next_upstream</a>\ndirective.</p><p dir=\"auto\">This Lua code execution context does not support yielding, so Lua APIs that may yield\n(like cosockets and \"light threads\") are disabled in this context. One can usually work\naround this limitation by doing such operations in an earlier phase handler (like\n<a href=\"#access_by_lua\">access_by_lua*</a>) and passing along the result into this context\nvia the <a href=\"#ngxctx\">ngx.ctx</a> table.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.0</code> release.</p>",["This directive runs Lua code as an upstream balancer for any upstream entities defined\nby the upstream {} configuration block.","For instance,"," upstream foo {\n     server 127.0.0.1;\n     balancer_by_lua_block {\n         -- use Lua to do something interesting here\n         -- as a dynamic balancer\n     }\n }\n\n server {\n     location / {\n         proxy_pass http://foo;\n     }\n }","The resulting Lua load balancer can work with any existing Nginx upstream modules\nlike ngx_proxy and\nngx_fastcgi.","Also, the Lua load balancer can work with the standard upstream connection pool mechanism,\ni.e., the standard keepalive directive.\nJust ensure that the keepalive directive\nis used after this balancer_by_lua_block directive in a single upstream {} configuration block.","The Lua load balancer can totally ignore the list of servers defined in the upstream {} block\nand select peer from a completely dynamic server list (even changing per request) via the\nngx.balancer module\nfrom the lua-resty-core library.","The Lua code handler registered by this directive might get called more than once in a single\ndownstream request when the Nginx upstream mechanism retries the request on conditions\nspecified by directives like the proxy_next_upstream\ndirective.","This Lua code execution context does not support yielding, so Lua APIs that may yield\n(like cosockets and \"light threads\") are disabled in this context. One can usually work\naround this limitation by doing such operations in an earlier phase handler (like\naccess_by_lua*) and passing along the result into this context\nvia the ngx.ctx table.","This directive was first introduced in the v0.10.0 release."],"<table ><tr><th>Syntax:</th><td><code><strong>balancer_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>balancer_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>upstream</code></td></tr></table>"],
[4,"balancer_by_lua_file","Equivalent to balancer_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#balancer_by_lua_block\">balancer_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.0</code> release.</p>",["Equivalent to balancer_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.10.0 release."],"<table ><tr><th>Syntax:</th><td><code><strong>balancer_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>balancer_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>upstream</code></td></tr></table>"],
[4,"lua_need_request_body","Determines whether to force the request body data to be read before running rewrite/access/content_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned on or the ngx.req.read_body function should be called within the Lua code.","<p dir=\"auto\">Determines whether to force the request body data to be read before running rewrite/access/content_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the <a href=\"#ngxreqread_body\">ngx.req.read_body</a> function should be called within the Lua code.</p><p dir=\"auto\">To read the request body data within the <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body\" rel=\"nofollow\">$request_body</a> variable,\n<a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size\" rel=\"nofollow\">client_body_buffer_size</a> must have the same value as <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size\" rel=\"nofollow\">client_max_body_size</a>. Because when the content length exceeds <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size\" rel=\"nofollow\">client_body_buffer_size</a> but less than <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size\" rel=\"nofollow\">client_max_body_size</a>, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body\" rel=\"nofollow\">$request_body</a> variable.</p><p dir=\"auto\">If the current location includes <a href=\"#rewrite_by_lua\">rewrite_by_lua*</a> directives,\nthen the request body will be read just before the <a href=\"#rewrite_by_lua\">rewrite_by_lua*</a> code is run (and also at the\n<code>rewrite</code> phase). Similarly, if only <a href=\"#content_by_lua\">content_by_lua</a> is specified,\nthe request body will not be read until the content handler's Lua code is\nabout to run (i.e., the request body will be read during the content phase).</p><p dir=\"auto\">It is recommended however, to use the <a href=\"#ngxreqread_body\">ngx.req.read_body</a> and <a href=\"#ngxreqdiscard_body\">ngx.req.discard_body</a> functions for finer control over the request body reading process instead.</p><p dir=\"auto\">This also applies to <a href=\"#access_by_lua\">access_by_lua*</a>.</p>",["Determines whether to force the request body data to be read before running rewrite/access/content_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned on or the ngx.req.read_body function should be called within the Lua code.","To read the request body data within the $request_body variable,\nclient_body_buffer_size must have the same value as client_max_body_size. Because when the content length exceeds client_body_buffer_size but less than client_max_body_size, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the $request_body variable.","If the current location includes rewrite_by_lua* directives,\nthen the request body will be read just before the rewrite_by_lua* code is run (and also at the\nrewrite phase). Similarly, if only content_by_lua is specified,\nthe request body will not be read until the content handler's Lua code is\nabout to run (i.e., the request body will be read during the content phase).","It is recommended however, to use the ngx.req.read_body and ngx.req.discard_body functions for finer control over the request body reading process instead.","This also applies to access_by_lua*."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_need_request_body <on|off></strong></code><br></td></tr><tr><th>Default:</th><td><pre>off</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location if</code></td></tr></table>"],
[4,"ssl_client_hello_by_lua_block","This directive runs user Lua code when Nginx is about to post-process the SSL client hello message for the downstream\nSSL (https) connections.","<p dir=\"auto\">This directive runs user Lua code when Nginx is about to post-process the SSL client hello message for the downstream\nSSL (https) connections.</p><p dir=\"auto\">It is particularly useful for dynamically setting the SSL protocols according to the SNI.</p><p dir=\"auto\">It is also useful to do some custom operations according to the per-connection information in the client hello message.</p><p dir=\"auto\">For example, one can parse custom client hello extension and do the corresponding handling in pure Lua.</p><p dir=\"auto\">This Lua handler will always run whether the SSL session is resumed (via SSL session IDs or TLS session tickets) or not.\nWhile the <code>ssl_certificate_by_lua*</code> Lua handler will only runs when initiating a full SSL handshake.</p><p dir=\"auto\">The <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/clienthello.md\">ngx.ssl.clienthello</a> Lua modules\nprovided by the <a href=\"https://github.com/openresty/lua-resty-core/#readme\">lua-resty-core</a>\nlibrary are particularly useful in this context.</p><p dir=\"auto\">Note that this handler runs in extremely early stage of SSL handshake, before the SSL client hello extensions are parsed.\nSo you can not use some Lua API like <code>ssl.server_name()</code> which is dependent on the later stage's processing.</p><p dir=\"auto\">Also note that only the directive in default server is valid for several virtual servers with the same IP address and port.</p><p dir=\"auto\">Below is a trivial example using the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/clienthello.md\">ngx.ssl.clienthello</a> module\nat the same time:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n server {\n     listen 443 ssl;\n     server_name   test.com;\n     ssl_certificate /path/to/cert.crt;\n     ssl_certificate_key /path/to/key.key;\n     ssl_client_hello_by_lua_block {\n         local ssl_clt = require &quot;ngx.ssl.clienthello&quot;\n         local host, err = ssl_clt.get_client_hello_server_name()\n         if host == &quot;test.com&quot; then\n             ssl_clt.set_protocols({&quot;TLSv1&quot;, &quot;TLSv1.1&quot;})\n         elseif host == &quot;test2.com&quot; then\n             ssl_clt.set_protocols({&quot;TLSv1.2&quot;, &quot;TLSv1.3&quot;})\n         elseif not host then\n             ngx.log(ngx.ERR, &quot;failed to get the SNI name: &quot;, err)\n             ngx.exit(ngx.ERROR)\n         else\n             ngx.log(ngx.ERR, &quot;unknown SNI name: &quot;, host)\n             ngx.exit(ngx.ERROR)\n         end\n     }\n     ...\n }\n server {\n     listen 443 ssl;\n     server_name   test2.com;\n     ssl_certificate /path/to/cert.crt;\n     ssl_certificate_key /path/to/key.key;\n     ...\n }\n\"><pre> <span class=\"pl-k\">server</span> {\n     <span class=\"pl-k\">listen</span> <span class=\"pl-s\">443</span> ssl;\n     <span class=\"pl-k\">server_name</span>   test.com;\n     <span class=\"pl-k\">ssl_certificate</span> /path/to/cert.crt;\n     <span class=\"pl-k\">ssl_certificate_key</span> /path/to/key.key;\n     <span class=\"pl-k\">ssl_client_hello_by_lua_block</span> {\n         <span class=\"pl-k\">local</span> ssl_clt = require <span class=\"pl-s\">\"ngx.ssl.clienthello\"</span>\n         <span class=\"pl-k\">local</span> host, err = ssl_clt.get_client_hello_server_name()\n         <span class=\"pl-k\">if</span> host == <span class=\"pl-s\">\"test.com\"</span> then\n             ssl_clt.set_protocols({\"TLSv1\", \"TLSv1.1\"})\n         <span class=\"pl-k\">elseif</span> host == <span class=\"pl-s\">\"test2.com\"</span> then\n             ssl_clt.set_protocols({\"TLSv1.2\", \"TLSv1.3\"})\n         <span class=\"pl-k\">elseif</span> not host then\n             ngx.log(ngx.ERR, \"<span class=\"pl-k\">failed</span> to get the SNI name: <span class=\"pl-s\">\", err)</span>\n<span class=\"pl-s\">             ngx.exit(ngx.ERROR)</span>\n<span class=\"pl-s\">         else</span>\n<span class=\"pl-s\">             ngx.log(ngx.ERR, \"</span>unknown SNI name: <span class=\"pl-s\">\", host)</span>\n<span class=\"pl-s\">             ngx.exit(ngx.ERROR)</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\">     }</span>\n<span class=\"pl-s\">     ...</span>\n<span class=\"pl-s\"> }</span>\n<span class=\"pl-s\"> server {</span>\n<span class=\"pl-s\">     listen 443 ssl;</span>\n<span class=\"pl-s\">     server_name   test2.com;</span>\n<span class=\"pl-s\">     ssl_certificate /path/to/cert.crt;</span>\n<span class=\"pl-s\">     ssl_certificate_key /path/to/key.key;</span>\n<span class=\"pl-s\">     ...</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">See more information in the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/clienthello.md\">ngx.ssl.clienthello</a>\nLua modules' official documentation.</p><p dir=\"auto\">Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the\n<a href=\"#ngxexit\">ngx.exit</a> call with an error code like <code>ngx.ERROR</code>.</p><p dir=\"auto\">This Lua code execution context <em>does</em> support yielding, so Lua APIs that may yield\n(like cosockets, sleeping, and \"light threads\")\nare enabled in this context</p><p dir=\"auto\">Note, you need to configure the <a href=\"https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate\" rel=\"nofollow\">ssl_certificate</a>\nand <a href=\"https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key\" rel=\"nofollow\">ssl_certificate_key</a>\nto avoid the following error while starting NGINX:</p><div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"nginx: [emerg] no ssl configured for the server\n\"><pre><code>nginx: [emerg] no ssl configured for the server\n</code></pre></div><p dir=\"auto\">This directive requires OpenSSL 1.1.1 or greater.</p><p dir=\"auto\">If you are using the <a href=\"https://openresty.org/en/linux-packages.html\" rel=\"nofollow\">official pre-built\npackages</a> for\n<a href=\"https://openresty.org/\" rel=\"nofollow\">OpenResty</a> 1.19.9.2 or later, then everything should\nwork out of the box.</p><p dir=\"auto\">If you are not using one of the <a href=\"https://openresty.org/en/linux-packages.html\" rel=\"nofollow\">OpenSSL\npackages</a> provided by\n<a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a>, you will need to apply patches to OpenSSL\nin order to use this directive:</p><p dir=\"auto\"><a href=\"https://openresty.org/en/openssl-patches.html\" rel=\"nofollow\">https://openresty.org/en/openssl-patches.html</a></p><p dir=\"auto\">Similarly, if you are not using the Nginx core shipped with\n<a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a> 1.19.9.2 or later, you will need to apply\npatches to the standard Nginx core:</p><p dir=\"auto\"><a href=\"https://openresty.org/en/nginx-ssl-patches.html\" rel=\"nofollow\">https://openresty.org/en/nginx-ssl-patches.html</a></p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.21</code> release.</p>",["This directive runs user Lua code when Nginx is about to post-process the SSL client hello message for the downstream\nSSL (https) connections.","It is particularly useful for dynamically setting the SSL protocols according to the SNI.","It is also useful to do some custom operations according to the per-connection information in the client hello message.","For example, one can parse custom client hello extension and do the corresponding handling in pure Lua.","This Lua handler will always run whether the SSL session is resumed (via SSL session IDs or TLS session tickets) or not.\nWhile the ssl_certificate_by_lua* Lua handler will only runs when initiating a full SSL handshake.","The ngx.ssl.clienthello Lua modules\nprovided by the lua-resty-core\nlibrary are particularly useful in this context.","Note that this handler runs in extremely early stage of SSL handshake, before the SSL client hello extensions are parsed.\nSo you can not use some Lua API like ssl.server_name() which is dependent on the later stage's processing.","Also note that only the directive in default server is valid for several virtual servers with the same IP address and port.","Below is a trivial example using the\nngx.ssl.clienthello module\nat the same time:"," server {\n     listen 443 ssl;\n     server_name   test.com;\n     ssl_certificate /path/to/cert.crt;\n     ssl_certificate_key /path/to/key.key;\n     ssl_client_hello_by_lua_block {\n         local ssl_clt = require \"ngx.ssl.clienthello\"\n         local host, err = ssl_clt.get_client_hello_server_name()\n         if host == \"test.com\" then\n             ssl_clt.set_protocols({\"TLSv1\", \"TLSv1.1\"})\n         elseif host == \"test2.com\" then\n             ssl_clt.set_protocols({\"TLSv1.2\", \"TLSv1.3\"})\n         elseif not host then\n             ngx.log(ngx.ERR, \"failed to get the SNI name: \", err)\n             ngx.exit(ngx.ERROR)\n         else\n             ngx.log(ngx.ERR, \"unknown SNI name: \", host)\n             ngx.exit(ngx.ERROR)\n         end\n     }\n     ...\n }\n server {\n     listen 443 ssl;\n     server_name   test2.com;\n     ssl_certificate /path/to/cert.crt;\n     ssl_certificate_key /path/to/key.key;\n     ...\n }","See more information in the ngx.ssl.clienthello\nLua modules' official documentation.","Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the\nngx.exit call with an error code like ngx.ERROR.","This Lua code execution context does support yielding, so Lua APIs that may yield\n(like cosockets, sleeping, and \"light threads\")\nare enabled in this context","Note, you need to configure the ssl_certificate\nand ssl_certificate_key\nto avoid the following error while starting NGINX:","nginx: [emerg] no ssl configured for the server\n","This directive requires OpenSSL 1.1.1 or greater.","If you are using the official pre-built\npackages for\nOpenResty 1.19.9.2 or later, then everything should\nwork out of the box.","If you are not using one of the OpenSSL\npackages provided by\nOpenResty, you will need to apply patches to OpenSSL\nin order to use this directive:","https://openresty.org/en/openssl-patches.html","Similarly, if you are not using the Nginx core shipped with\nOpenResty 1.19.9.2 or later, you will need to apply\npatches to the standard Nginx core:","https://openresty.org/en/nginx-ssl-patches.html","This directive was first introduced in the v0.10.21 release."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_client_hello_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_client_hello_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code></td></tr></table>"],
[4,"ssl_client_hello_by_lua_file","Equivalent to ssl_client_hello_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#ssl_client_hello_by_lua_block\">ssl_client_hello_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.21</code> release.</p>",["Equivalent to ssl_client_hello_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.10.21 release."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_client_hello_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_client_hello_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code></td></tr></table>"],
[4,"ssl_certificate_by_lua_block","This directive runs user Lua code when Nginx is about to start the SSL handshake for the downstream\nSSL (https) connections.","<p dir=\"auto\">This directive runs user Lua code when Nginx is about to start the SSL handshake for the downstream\nSSL (https) connections.</p><p dir=\"auto\">It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request\nbasis. It is also useful to load such handshake configurations nonblockingly from the remote (for example,\nwith the <a href=\"#ngxsockettcp\">cosocket</a> API). And one can also do per-request OCSP stapling handling in pure\nLua here as well.</p><p dir=\"auto\">Another typical use case is to do SSL handshake traffic control nonblockingly in this context,\nwith the help of the <a href=\"https://github.com/openresty/lua-resty-limit-traffic\">lua-resty-limit-traffic#readme</a>\nlibrary, for example.</p><p dir=\"auto\">One can also do interesting things with the SSL handshake requests from the client side, like\nrejecting old SSL clients using the SSLv3 protocol or even below selectively.</p><p dir=\"auto\">The <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md\">ngx.ssl</a>\nand <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md\">ngx.ocsp</a> Lua modules\nprovided by the <a href=\"https://github.com/openresty/lua-resty-core/#readme\">lua-resty-core</a>\nlibrary are particularly useful in this context. You can use the Lua API offered by these two Lua modules\nto manipulate the SSL certificate chain and private key for the current SSL connection\nbeing initiated.</p><p dir=\"auto\">This Lua handler does not run at all, however, when Nginx/OpenSSL successfully resumes\nthe SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In\nother words, this Lua handler only runs when Nginx has to initiate a full SSL handshake.</p><p dir=\"auto\">Below is a trivial example using the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md\">ngx.ssl</a> module\nat the same time:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n server {\n     listen 443 ssl;\n     server_name   test.com;\n\n     ssl_certificate_by_lua_block {\n         print(&quot;About to initiate a new SSL handshake!&quot;)\n     }\n\n     location / {\n         root html;\n     }\n }\n\"><pre> <span class=\"pl-k\">server</span> {\n     <span class=\"pl-k\">listen</span> <span class=\"pl-s\">443</span> ssl;\n     <span class=\"pl-k\">server_name</span>   test.com;\n\n     <span class=\"pl-k\">ssl_certificate_by_lua_block</span> {\n         print(\"<span class=\"pl-k\">About</span> to initiate <span class=\"pl-s\">a</span> new SSL handshake!<span class=\"pl-s\">\")</span>\n<span class=\"pl-s\">     }</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">     location / {</span>\n<span class=\"pl-s\">         root html;</span>\n<span class=\"pl-s\">     }</span>\n<span class=\"pl-s\"> }</span></pre></div><p dir=\"auto\">See more complicated examples in the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md\">ngx.ssl</a>\nand <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md\">ngx.ocsp</a>\nLua modules' official documentation.</p><p dir=\"auto\">Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the\n<a href=\"#ngxexit\">ngx.exit</a> call with an error code like <code>ngx.ERROR</code>.</p><p dir=\"auto\">This Lua code execution context <em>does</em> support yielding, so Lua APIs that may yield\n(like cosockets, sleeping, and \"light threads\")\nare enabled in this context.</p><p dir=\"auto\">Note, however, you still need to configure the <a href=\"https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate\" rel=\"nofollow\">ssl_certificate</a> and\n<a href=\"https://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key\" rel=\"nofollow\">ssl_certificate_key</a>\ndirectives even though you will not use this static certificate and private key at all. This is\nbecause the NGINX core requires their appearance otherwise you are seeing the following error\nwhile starting NGINX:</p><div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"nginx: [emerg] no ssl configured for the server\n\"><pre><code>nginx: [emerg] no ssl configured for the server\n</code></pre></div><p dir=\"auto\">This directive requires OpenSSL 1.0.2e or greater.</p><p dir=\"auto\">If you are using the <a href=\"https://openresty.org/en/linux-packages.html\" rel=\"nofollow\">official pre-built\npackages</a> for\n<a href=\"https://openresty.org/\" rel=\"nofollow\">OpenResty</a> 1.9.7.2 or later, then everything should\nwork out of the box.</p><p dir=\"auto\">If you are not using one of the <a href=\"https://openresty.org/en/linux-packages.html\" rel=\"nofollow\">OpenSSL\npackages</a> provided by\n<a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a>, you will need to apply patches to OpenSSL\nin order to use this directive:</p><p dir=\"auto\"><a href=\"https://openresty.org/en/openssl-patches.html\" rel=\"nofollow\">https://openresty.org/en/openssl-patches.html</a></p><p dir=\"auto\">Similarly, if you are not using the Nginx core shipped with\n<a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a> 1.9.7.2 or later, you will need to apply\npatches to the standard Nginx core:</p><p dir=\"auto\"><a href=\"https://openresty.org/en/nginx-ssl-patches.html\" rel=\"nofollow\">https://openresty.org/en/nginx-ssl-patches.html</a></p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.0</code> release.</p>",["This directive runs user Lua code when Nginx is about to start the SSL handshake for the downstream\nSSL (https) connections.","It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request\nbasis. It is also useful to load such handshake configurations nonblockingly from the remote (for example,\nwith the cosocket API). And one can also do per-request OCSP stapling handling in pure\nLua here as well.","Another typical use case is to do SSL handshake traffic control nonblockingly in this context,\nwith the help of the lua-resty-limit-traffic#readme\nlibrary, for example.","One can also do interesting things with the SSL handshake requests from the client side, like\nrejecting old SSL clients using the SSLv3 protocol or even below selectively.","The ngx.ssl\nand ngx.ocsp Lua modules\nprovided by the lua-resty-core\nlibrary are particularly useful in this context. You can use the Lua API offered by these two Lua modules\nto manipulate the SSL certificate chain and private key for the current SSL connection\nbeing initiated.","This Lua handler does not run at all, however, when Nginx/OpenSSL successfully resumes\nthe SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In\nother words, this Lua handler only runs when Nginx has to initiate a full SSL handshake.","Below is a trivial example using the\nngx.ssl module\nat the same time:"," server {\n     listen 443 ssl;\n     server_name   test.com;\n\n     ssl_certificate_by_lua_block {\n         print(\"About to initiate a new SSL handshake!\")\n     }\n\n     location / {\n         root html;\n     }\n }","See more complicated examples in the ngx.ssl\nand ngx.ocsp\nLua modules' official documentation.","Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the\nngx.exit call with an error code like ngx.ERROR.","This Lua code execution context does support yielding, so Lua APIs that may yield\n(like cosockets, sleeping, and \"light threads\")\nare enabled in this context.","Note, however, you still need to configure the ssl_certificate and\nssl_certificate_key\ndirectives even though you will not use this static certificate and private key at all. This is\nbecause the NGINX core requires their appearance otherwise you are seeing the following error\nwhile starting NGINX:","nginx: [emerg] no ssl configured for the server\n","This directive requires OpenSSL 1.0.2e or greater.","If you are using the official pre-built\npackages for\nOpenResty 1.9.7.2 or later, then everything should\nwork out of the box.","If you are not using one of the OpenSSL\npackages provided by\nOpenResty, you will need to apply patches to OpenSSL\nin order to use this directive:","https://openresty.org/en/openssl-patches.html","Similarly, if you are not using the Nginx core shipped with\nOpenResty 1.9.7.2 or later, you will need to apply\npatches to the standard Nginx core:","https://openresty.org/en/nginx-ssl-patches.html","This directive was first introduced in the v0.10.0 release."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_certificate_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_certificate_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>server</code></td></tr></table>"],
[4,"ssl_certificate_by_lua_file","Equivalent to ssl_certificate_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.0</code> release.</p>",["Equivalent to ssl_certificate_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or, as from the v0.5.0rc32 release, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.10.0 release."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_certificate_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_certificate_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>server</code></td></tr></table>"],
[4,"ssl_session_fetch_by_lua_block","This directive runs Lua code to look up and load the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream.","<p dir=\"auto\">This directive runs Lua code to look up and load the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream.</p><p dir=\"auto\">The Lua API for obtaining the current session ID and loading a cached SSL session data\nis provided in the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md\">ngx.ssl.session</a>\nLua module shipped with the <a href=\"https://github.com/openresty/lua-resty-core#readme\">lua-resty-core</a>\nlibrary.</p><p dir=\"auto\">Lua APIs that may yield, like <a href=\"#ngxsleep\">ngx.sleep</a> and <a href=\"#ngxsockettcp\">cosockets</a>,\nare enabled in this context.</p><p dir=\"auto\">This hook, together with the <a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua*</a> hook,\ncan be used to implement distributed caching mechanisms in pure Lua (based\non the <a href=\"#ngxsockettcp\">cosocket</a> API, for example). If a cached SSL session is found\nand loaded into the current SSL connection context,\nSSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.</p><p dir=\"auto\">Please note that TLS session tickets are very different and it is the clients' responsibility\nto cache the SSL session state when session tickets are used. SSL session resumptions based on\nTLS session tickets would happen automatically without going through this hook (nor the\n<a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua*</a> hook). This hook is mainly\nfor older or less capable SSL clients that can only do SSL sessions by session IDs.</p><p dir=\"auto\">When <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua*</a> is specified at the same time,\nthis hook usually runs before <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua*</a>.\nWhen the SSL session is found and successfully loaded for the current SSL connection,\nSSL session resumption will happen and thus bypass the <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua*</a>\nhook completely. In this case, Nginx also bypasses the <a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua*</a>\nhook, for obvious reasons.</p><p dir=\"auto\">To easily test this hook locally with a modern web browser, you can temporarily put the following line\nin your https server block to disable the TLS session ticket support:</p><div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"ssl_session_tickets off;\n\"><pre><code>ssl_session_tickets off;\n</code></pre></div><p dir=\"auto\">But do not forget to comment this line out before publishing your site to the world.</p><p dir=\"auto\">If you are using the <a href=\"https://openresty.org/en/linux-packages.html\" rel=\"nofollow\">official pre-built packages</a> for <a href=\"https://openresty.org/\" rel=\"nofollow\">OpenResty</a>\n1.11.2.1 or later, then everything should work out of the box.</p><p dir=\"auto\">If you are not using one of the <a href=\"https://openresty.org/en/linux-packages.html\" rel=\"nofollow\">OpenSSL\npackages</a> provided by\n<a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a>, you will need to apply patches to OpenSSL\nin order to use this directive:</p><p dir=\"auto\"><a href=\"https://openresty.org/en/openssl-patches.html\" rel=\"nofollow\">https://openresty.org/en/openssl-patches.html</a></p><p dir=\"auto\">Similarly, if you are not using the Nginx core shipped with\n<a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a> 1.11.2.1 or later, you will need to apply\npatches to the standard Nginx core:</p><p dir=\"auto\"><a href=\"https://openresty.org/en/nginx-ssl-patches.html\" rel=\"nofollow\">https://openresty.org/en/nginx-ssl-patches.html</a></p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.6</code> release.</p><p dir=\"auto\">Note that this directive can only be used in the <strong>http context</strong> starting\nwith the <code>v0.10.7</code> release since SSL session resumption happens\nbefore server name dispatch.</p>",["This directive runs Lua code to look up and load the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream.","The Lua API for obtaining the current session ID and loading a cached SSL session data\nis provided in the ngx.ssl.session\nLua module shipped with the lua-resty-core\nlibrary.","Lua APIs that may yield, like ngx.sleep and cosockets,\nare enabled in this context.","This hook, together with the ssl_session_store_by_lua* hook,\ncan be used to implement distributed caching mechanisms in pure Lua (based\non the cosocket API, for example). If a cached SSL session is found\nand loaded into the current SSL connection context,\nSSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.","Please note that TLS session tickets are very different and it is the clients' responsibility\nto cache the SSL session state when session tickets are used. SSL session resumptions based on\nTLS session tickets would happen automatically without going through this hook (nor the\nssl_session_store_by_lua* hook). This hook is mainly\nfor older or less capable SSL clients that can only do SSL sessions by session IDs.","When ssl_certificate_by_lua* is specified at the same time,\nthis hook usually runs before ssl_certificate_by_lua*.\nWhen the SSL session is found and successfully loaded for the current SSL connection,\nSSL session resumption will happen and thus bypass the ssl_certificate_by_lua*\nhook completely. In this case, Nginx also bypasses the ssl_session_store_by_lua*\nhook, for obvious reasons.","To easily test this hook locally with a modern web browser, you can temporarily put the following line\nin your https server block to disable the TLS session ticket support:","ssl_session_tickets off;\n","But do not forget to comment this line out before publishing your site to the world.","If you are using the official pre-built packages for OpenResty\n1.11.2.1 or later, then everything should work out of the box.","If you are not using one of the OpenSSL\npackages provided by\nOpenResty, you will need to apply patches to OpenSSL\nin order to use this directive:","https://openresty.org/en/openssl-patches.html","Similarly, if you are not using the Nginx core shipped with\nOpenResty 1.11.2.1 or later, you will need to apply\npatches to the standard Nginx core:","https://openresty.org/en/nginx-ssl-patches.html","This directive was first introduced in the v0.10.6 release.","Note that this directive can only be used in the http context starting\nwith the v0.10.7 release since SSL session resumption happens\nbefore server name dispatch."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_fetch_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_fetch_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"ssl_session_fetch_by_lua_file","Equivalent to ssl_session_fetch_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or rather, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#ssl_session_fetch_by_lua_block\">ssl_session_fetch_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.6</code> release.</p><p dir=\"auto\">Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release\n(because SSL session resumption happens before server name dispatch).</p>",["Equivalent to ssl_session_fetch_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or rather, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.10.6 release.","Note that: this directive is only allowed to used in http context from the v0.10.7 release\n(because SSL session resumption happens before server name dispatch)."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_fetch_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_fetch_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"ssl_session_store_by_lua_block","This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream. The saved or cached SSL\nsession data can be used for future SSL connections to resume SSL sessions without going\nthrough the full SSL handshake process (which is very expensive in terms of CPU time).","<p dir=\"auto\">This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream. The saved or cached SSL\nsession data can be used for future SSL connections to resume SSL sessions without going\nthrough the full SSL handshake process (which is very expensive in terms of CPU time).</p><p dir=\"auto\">Lua APIs that may yield, like <a href=\"#ngxsleep\">ngx.sleep</a> and <a href=\"#ngxsockettcp\">cosockets</a>,\nare <em>disabled</em> in this context. You can still, however, use the <a href=\"#ngxtimerat\">ngx.timer.at</a> API\nto create 0-delay timers to save the SSL session data asynchronously to external services (like <code>redis</code> or <code>memcached</code>).</p><p dir=\"auto\">The Lua API for obtaining the current session ID and the associated session state data\nis provided in the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme\">ngx.ssl.session</a>\nLua module shipped with the <a href=\"https://github.com/openresty/lua-resty-core#readme\">lua-resty-core</a>\nlibrary.</p><p dir=\"auto\">To easily test this hook locally with a modern web browser, you can temporarily put the following line\nin your https server block to disable the TLS session ticket support:</p><div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"ssl_session_tickets off;\n\"><pre><code>ssl_session_tickets off;\n</code></pre></div><p dir=\"auto\">But do not forget to comment this line out before publishing your site to the world.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.6</code> release.</p><p dir=\"auto\">Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release\n(because SSL session resumption happens before server name dispatch).</p>",["This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream. The saved or cached SSL\nsession data can be used for future SSL connections to resume SSL sessions without going\nthrough the full SSL handshake process (which is very expensive in terms of CPU time).","Lua APIs that may yield, like ngx.sleep and cosockets,\nare disabled in this context. You can still, however, use the ngx.timer.at API\nto create 0-delay timers to save the SSL session data asynchronously to external services (like redis or memcached).","The Lua API for obtaining the current session ID and the associated session state data\nis provided in the ngx.ssl.session\nLua module shipped with the lua-resty-core\nlibrary.","To easily test this hook locally with a modern web browser, you can temporarily put the following line\nin your https server block to disable the TLS session ticket support:","ssl_session_tickets off;\n","But do not forget to comment this line out before publishing your site to the world.","This directive was first introduced in the v0.10.6 release.","Note that: this directive is only allowed to used in http context from the v0.10.7 release\n(because SSL session resumption happens before server name dispatch)."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_store_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_store_by_lua_block {}</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"ssl_session_store_by_lua_file","Equivalent to ssl_session_store_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or rather, the LuaJIT bytecode to be executed.","<p dir=\"auto\">Equivalent to <a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href=\"#luajit-bytecode-support\">LuaJIT bytecode</a> to be executed.</p><p dir=\"auto\">When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.6</code> release.</p><p dir=\"auto\">Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release\n(because SSL session resumption happens before server name dispatch).</p>",["Equivalent to ssl_session_store_by_lua_block, except that the file specified by <path-to-lua-script-file> contains the Lua code, or rather, the LuaJIT bytecode to be executed.","When a relative path like foo/bar.lua is given, they will be turned into the absolute path relative to the server prefix path determined by the -p PATH command-line option while starting the Nginx server.","This directive was first introduced in the v0.10.6 release.","Note that: this directive is only allowed to used in http context from the v0.10.7 release\n(because SSL session resumption happens before server name dispatch)."],"<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_store_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_store_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_shared_dict","Declares a shared memory zone, <name>, to serve as storage for the shm based Lua dictionary ngx.shared.<name>.","<p dir=\"auto\">Declares a shared memory zone, <code>&lt;name&gt;</code>, to serve as storage for the shm based Lua dictionary <code>ngx.shared.&lt;name&gt;</code>.</p><p dir=\"auto\">Shared memory zones are always shared by all the Nginx worker processes in the current Nginx server instance.</p><p dir=\"auto\">The <code>&lt;size&gt;</code> argument accepts size units such as <code>k</code> and <code>m</code>:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n http {\n     lua_shared_dict dogs 10m;\n     ...\n }\n\"><pre> <span class=\"pl-k\">http</span> {\n     <span class=\"pl-k\">lua_shared_dict</span> dogs <span class=\"pl-c1\">10m</span>;\n     ...\n }</pre></div><p dir=\"auto\">The hard-coded minimum size is 8KB while the practical minimum size depends\non actual user data set (some people start with 12KB).</p><p dir=\"auto\">See <a href=\"#ngxshareddict\">ngx.shared.DICT</a> for details.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.3.1rc22</code> release.</p>",["Declares a shared memory zone, <name>, to serve as storage for the shm based Lua dictionary ngx.shared.<name>.","Shared memory zones are always shared by all the Nginx worker processes in the current Nginx server instance.","The <size> argument accepts size units such as k and m:"," http {\n     lua_shared_dict dogs 10m;\n     ...\n }","The hard-coded minimum size is 8KB while the practical minimum size depends\non actual user data set (some people start with 12KB).","See ngx.shared.DICT for details.","This directive was first introduced in the v0.3.1rc22 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_shared_dict <name> <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_shared_dict ;</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_socket_connect_timeout","This directive controls the default timeout value used in TCP/unix-domain socket object's connect method and can be overridden by the settimeout or settimeouts methods.","<p dir=\"auto\">This directive controls the default timeout value used in TCP/unix-domain socket object's <a href=\"#tcpsockconnect\">connect</a> method and can be overridden by the <a href=\"#tcpsocksettimeout\">settimeout</a> or <a href=\"#tcpsocksettimeouts\">settimeouts</a> methods.</p><p dir=\"auto\">The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., \"second\". The default setting is <code>60s</code>.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",["This directive controls the default timeout value used in TCP/unix-domain socket object's connect method and can be overridden by the settimeout or settimeouts methods.","The <time> argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \"second\". The default setting is 60s.","This directive was first introduced in the v0.5.0rc1 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_connect_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_connect_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_socket_send_timeout","Controls the default timeout value used in TCP/unix-domain socket object's send method and can be overridden by the settimeout or settimeouts methods.","<p dir=\"auto\">Controls the default timeout value used in TCP/unix-domain socket object's <a href=\"#tcpsocksend\">send</a> method and can be overridden by the <a href=\"#tcpsocksettimeout\">settimeout</a> or <a href=\"#tcpsocksettimeouts\">settimeouts</a> methods.</p><p dir=\"auto\">The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., \"second\". The default setting is <code>60s</code>.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",["Controls the default timeout value used in TCP/unix-domain socket object's send method and can be overridden by the settimeout or settimeouts methods.","The <time> argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \"second\". The default setting is 60s.","This directive was first introduced in the v0.5.0rc1 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_send_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_send_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_socket_send_lowat","Controls the lowat (low water) value for the cosocket send buffer.","<p dir=\"auto\">Controls the <code>lowat</code> (low water) value for the cosocket send buffer.</p>",["Controls the lowat (low water) value for the cosocket send buffer."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_send_lowat <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_send_lowat 0</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_socket_read_timeout","This directive controls the default timeout value used in TCP/unix-domain socket object's receive method and iterator functions returned by the receiveuntil method. This setting can be overridden by the settimeout or settimeouts methods.","<p dir=\"auto\">This directive controls the default timeout value used in TCP/unix-domain socket object's <a href=\"#tcpsockreceive\">receive</a> method and iterator functions returned by the <a href=\"#tcpsockreceiveuntil\">receiveuntil</a> method. This setting can be overridden by the <a href=\"#tcpsocksettimeout\">settimeout</a> or <a href=\"#tcpsocksettimeouts\">settimeouts</a> methods.</p><p dir=\"auto\">The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., \"second\". The default setting is <code>60s</code>.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",["This directive controls the default timeout value used in TCP/unix-domain socket object's receive method and iterator functions returned by the receiveuntil method. This setting can be overridden by the settimeout or settimeouts methods.","The <time> argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \"second\". The default setting is 60s.","This directive was first introduced in the v0.5.0rc1 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_read_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_read_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_socket_buffer_size","Specifies the buffer size used by cosocket reading operations.","<p dir=\"auto\">Specifies the buffer size used by cosocket reading operations.</p><p dir=\"auto\">This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",["Specifies the buffer size used by cosocket reading operations.","This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even 1 byte buffer size should still work everywhere but the performance could be terrible.","This directive was first introduced in the v0.5.0rc1 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_buffer_size <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_buffer_size 4k/8k</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_socket_pool_size","Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).","<p dir=\"auto\">Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</p><p dir=\"auto\">Default to 30 connections for every pool.</p><p dir=\"auto\">When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</p><p dir=\"auto\">Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so size limit specified here also applies to every single Nginx worker process.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",["Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).","Default to 30 connections for every pool.","When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.","Note that the cosocket connection pool is per Nginx worker process rather than per Nginx server instance, so size limit specified here also applies to every single Nginx worker process.","This directive was first introduced in the v0.5.0rc1 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_pool_size <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_pool_size 30</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_socket_keepalive_timeout","This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' setkeepalive method.","<p dir=\"auto\">This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' <a href=\"#tcpsocksetkeepalive\">setkeepalive</a> method.</p><p dir=\"auto\">The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., \"second\". The default setting is <code>60s</code>.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",["This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects' setkeepalive method.","The <time> argument can be an integer, with an optional time unit, like s (second), ms (millisecond), m (minute). The default time unit is s, i.e., \"second\". The default setting is 60s.","This directive was first introduced in the v0.5.0rc1 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_keepalive_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_keepalive_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_socket_log_errors","This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your Nginx error log files (which is usually rather expensive).","<p dir=\"auto\">This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your Nginx error log files (which is usually rather expensive).</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.13</code> release.</p>",["This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your Nginx error log files (which is usually rather expensive).","This directive was first introduced in the v0.5.13 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_log_errors on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_log_errors on</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_ssl_ciphers","Specifies the enabled ciphers for requests to a SSL/TLS server in the tcpsock:sslhandshake method. The ciphers are specified in the format understood by the OpenSSL library.","<p dir=\"auto\">Specifies the enabled ciphers for requests to a SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method. The ciphers are specified in the format understood by the OpenSSL library.</p><p dir=\"auto\">The full list can be viewed using the openssl ciphers command.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.11</code> release.</p>",["Specifies the enabled ciphers for requests to a SSL/TLS server in the tcpsock:sslhandshake method. The ciphers are specified in the format understood by the OpenSSL library.","The full list can be viewed using the openssl ciphers command.","This directive was first introduced in the v0.9.11 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_ciphers <ciphers></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_ciphers DEFAULT</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_ssl_crl","Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the tcpsock:sslhandshake method.","<p dir=\"auto\">Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.11</code> release.</p>",["Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the tcpsock:sslhandshake method.","This directive was first introduced in the v0.9.11 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_crl <file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_crl ;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_ssl_protocols","Enables the specified protocols for requests to a SSL/TLS server in the tcpsock:sslhandshake method.","<p dir=\"auto\">Enables the specified protocols for requests to a SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method.</p><p dir=\"auto\">The support for the <code>TLSv1.3</code> parameter requires version <code>v0.10.12</code> <em>and</em> OpenSSL 1.1.1.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.11</code> release.</p>",["Enables the specified protocols for requests to a SSL/TLS server in the tcpsock:sslhandshake method.","The support for the TLSv1.3 parameter requires version v0.10.12 and OpenSSL 1.1.1.","This directive was first introduced in the v0.9.11 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_ssl_trusted_certificate","Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the tcpsock:sslhandshake method.","<p dir=\"auto\">Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.11</code> release.</p><p dir=\"auto\">See also <a href=\"#lua_ssl_verify_depth\">lua_ssl_verify_depth</a>.</p>",["Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the tcpsock:sslhandshake method.","This directive was first introduced in the v0.9.11 release.","See also lua_ssl_verify_depth."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_trusted_certificate <file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_trusted_certificate ;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_ssl_verify_depth","Sets the verification depth in the server certificates chain.","<p dir=\"auto\">Sets the verification depth in the server certificates chain.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.11</code> release.</p><p dir=\"auto\">See also <a href=\"#lua_ssl_trusted_certificate\">lua_ssl_trusted_certificate</a>.</p>",["Sets the verification depth in the server certificates chain.","This directive was first introduced in the v0.9.11 release.","See also lua_ssl_trusted_certificate."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_verify_depth <number></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_verify_depth 1</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_ssl_conf_command","Sets arbitrary OpenSSL configuration commands.","<p dir=\"auto\">Sets arbitrary OpenSSL configuration <a href=\"https://www.openssl.org/docs/man1.1.1/man3/SSL_CONF_cmd.html\" rel=\"nofollow\">commands</a>.</p><p dir=\"auto\">The directive is supported when using OpenSSL 1.0.2 or higher and nginx 1.19.4 or higher. According to the specify command, higher OpenSSL version may be needed.</p><p dir=\"auto\">Several <code>lua_ssl_conf_command</code> directives can be specified on the same level:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n lua_ssl_conf_command Options PrioritizeChaCha;\n lua_ssl_conf_command Ciphersuites TLS_CHACHA20_POLY1305_SHA256;\n\"><pre> <span class=\"pl-k\">lua_ssl_conf_command</span> Options PrioritizeChaCha;\n <span class=\"pl-k\">lua_ssl_conf_command</span> Ciphersuites TLS_CHACHA20_POLY1305_SHA256;</pre></div><p dir=\"auto\">Configuration commands are applied after OpenResty own configuration for SSL, so they can be used to override anything set by OpenResty.</p><p dir=\"auto\">Note though that configuring OpenSSL directly with <code>lua_ssl_conf_command</code> might result in a behaviour OpenResty does not expect, and should be done with care.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.21</code> release.</p>",["Sets arbitrary OpenSSL configuration commands.","The directive is supported when using OpenSSL 1.0.2 or higher and nginx 1.19.4 or higher. According to the specify command, higher OpenSSL version may be needed.","Several lua_ssl_conf_command directives can be specified on the same level:"," lua_ssl_conf_command Options PrioritizeChaCha;\n lua_ssl_conf_command Ciphersuites TLS_CHACHA20_POLY1305_SHA256;","Configuration commands are applied after OpenResty own configuration for SSL, so they can be used to override anything set by OpenResty.","Note though that configuring OpenSSL directly with lua_ssl_conf_command might result in a behaviour OpenResty does not expect, and should be done with care.","This directive was first introduced in the v0.10.21 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_conf_command <command></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_conf_command ;</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code></td></tr></table>"],
[4,"lua_http10_buffering","Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper Content-Length response header.","<p dir=\"auto\">Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper <code>Content-Length</code> response header.</p><p dir=\"auto\">If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicitly via <a href=\"#ngxsend_headers\">ngx.send_headers</a> or implicitly via the first <a href=\"#ngxsay\">ngx.say</a> or <a href=\"#ngxprint\">ngx.print</a> call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</p><p dir=\"auto\">To output very large response data in a streaming fashion (via the <a href=\"#ngxflush\">ngx.flush</a> call, for example), this directive MUST be turned off to minimize memory usage.</p><p dir=\"auto\">This directive is turned <code>on</code> by default.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc19</code> release.</p>",["Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper Content-Length response header.","If the Lua code explicitly sets a Content-Length response header before sending the headers (either explicitly via ngx.send_headers or implicitly via the first ngx.say or ngx.print call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.","To output very large response data in a streaming fashion (via the ngx.flush call, for example), this directive MUST be turned off to minimize memory usage.","This directive is turned on by default.","This directive was first introduced in the v0.5.0rc19 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_http10_buffering on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_http10_buffering on</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location-if</code></td></tr></table>"],
[4,"rewrite_by_lua_no_postpone","Controls whether or not to disable postponing rewrite_by_lua* directives to run at the end of the rewrite request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the rewrite phase.","<p dir=\"auto\">Controls whether or not to disable postponing <a href=\"#rewrite_by_lua\">rewrite_by_lua*</a> directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc29</code> release.</p>",["Controls whether or not to disable postponing rewrite_by_lua* directives to run at the end of the rewrite request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the rewrite phase.","This directive was first introduced in the v0.5.0rc29 release."],"<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua_no_postpone on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua_no_postpone off</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"access_by_lua_no_postpone","Controls whether or not to disable postponing access_by_lua* directives to run at the end of the access request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the access phase.","<p dir=\"auto\">Controls whether or not to disable postponing <a href=\"#access_by_lua\">access_by_lua*</a> directives to run at the end of the <code>access</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>access</code> phase.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.9.20</code> release.</p>",["Controls whether or not to disable postponing access_by_lua* directives to run at the end of the access request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the access phase.","This directive was first introduced in the v0.9.20 release."],"<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua_no_postpone on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua_no_postpone off</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_transform_underscores_in_response_headers","Controls whether to transform underscores (_) in the response header names specified in the ngx.header.HEADER API to hyphens (-).","<p dir=\"auto\">Controls whether to transform underscores (<code>_</code>) in the response header names specified in the <a href=\"#ngxheaderheader\">ngx.header.HEADER</a> API to hyphens (<code>-</code>).</p><p dir=\"auto\">This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>",["Controls whether to transform underscores (_) in the response header names specified in the ngx.header.HEADER API to hyphens (-).","This directive was first introduced in the v0.5.0rc32 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_transform_underscores_in_response_headers on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_transform_underscores_in_response_headers on</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location-if</code></td></tr></table>"],
[4,"lua_check_client_abort","This directive controls whether to check for premature client connection abortion.","<p dir=\"auto\">This directive controls whether to check for premature client connection abortion.</p><p dir=\"auto\">When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by <a href=\"#ngxon_abort\">ngx.on_abort</a>) or just stop and clean up all the Lua \"light threads\" running in the current request's request handler when there is no user callback function registered.</p><p dir=\"auto\">According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via <a href=\"#ngxreqsocket\">ngx.req.socket</a>, then ngx_lua will neither stop all the running \"light threads\" nor call the user callback (if <a href=\"#ngxon_abort\">ngx.on_abort</a> has been called). Instead, the reading operation on <a href=\"#ngxreqsocket\">ngx.req.socket</a> will just return the error message \"client aborted\" as the second return value (the first return value is surely <code>nil</code>).</p><p dir=\"auto\">When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a <code>FIN</code> packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the <a href=\"http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html\" rel=\"nofollow\">TCP keepalive</a> support in your system's TCP stack implementation in order to detect \"half-open\" TCP connections in time.</p><p dir=\"auto\">For example, on Linux, you can configure the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#listen\" rel=\"nofollow\">listen</a> directive in your <code>nginx.conf</code> file like this:</p><div class=\"highlight highlight-source-nginx position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"\n listen 80 so_keepalive=2s:2s:8;\n\"><pre> <span class=\"pl-k\">listen</span> <span class=\"pl-s\">80</span> so_keepalive=2s:2s:8;</pre></div><p dir=\"auto\">On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</p><div class=\"snippet-clipboard-content position-relative overflow-auto\" data-snippet-clipboard-copy-content=\"# sysctl net.inet.tcp.keepintvl=2000\n# sysctl net.inet.tcp.keepidle=2000\n\"><pre><code># sysctl net.inet.tcp.keepintvl=2000\n# sysctl net.inet.tcp.keepidle=2000\n</code></pre></div><p dir=\"auto\">This directive was first introduced in the <code>v0.7.4</code> release.</p><p dir=\"auto\">See also <a href=\"#ngxon_abort\">ngx.on_abort</a>.</p>",["This directive controls whether to check for premature client connection abortion.","When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by ngx.on_abort) or just stop and clean up all the Lua \"light threads\" running in the current request's request handler when there is no user callback function registered.","According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via ngx.req.socket, then ngx_lua will neither stop all the running \"light threads\" nor call the user callback (if ngx.on_abort has been called). Instead, the reading operation on ngx.req.socket will just return the error message \"client aborted\" as the second return value (the first return value is surely nil).","When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a FIN packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the TCP keepalive support in your system's TCP stack implementation in order to detect \"half-open\" TCP connections in time.","For example, on Linux, you can configure the standard listen directive in your nginx.conf file like this:"," listen 80 so_keepalive=2s:2s:8;","On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:","# sysctl net.inet.tcp.keepintvl=2000\n# sysctl net.inet.tcp.keepidle=2000\n","This directive was first introduced in the v0.7.4 release.","See also ngx.on_abort."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_check_client_abort on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_check_client_abort off</pre></td></tr><tr><th>Context:</th><td><code>http</code>,<code>server</code>,<code>location</code>,<code>location-if</code></td></tr></table>"],
[4,"lua_max_pending_timers","Controls the maximum number of pending timers allowed.","<p dir=\"auto\">Controls the maximum number of pending timers allowed.</p><p dir=\"auto\">Pending timers are those timers that have not expired yet.</p><p dir=\"auto\">When exceeding this limit, the <a href=\"#ngxtimerat\">ngx.timer.at</a> call will immediately return <code>nil</code> and the error string \"too many pending timers\".</p><p dir=\"auto\">This directive was first introduced in the <code>v0.8.0</code> release.</p>",["Controls the maximum number of pending timers allowed.","Pending timers are those timers that have not expired yet.","When exceeding this limit, the ngx.timer.at call will immediately return nil and the error string \"too many pending timers\".","This directive was first introduced in the v0.8.0 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_max_pending_timers <count></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_max_pending_timers 1024</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_max_running_timers","Controls the maximum number of \"running timers\" allowed.","<p dir=\"auto\">Controls the maximum number of \"running timers\" allowed.</p><p dir=\"auto\">Running timers are those timers whose user callback functions are still running.</p><p dir=\"auto\">When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message \"N lua_max_running_timers are not enough\" where \"N\" is the current value of this directive.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.8.0</code> release.</p>",["Controls the maximum number of \"running timers\" allowed.","Running timers are those timers whose user callback functions are still running.","When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message \"N lua_max_running_timers are not enough\" where \"N\" is the current value of this directive.","This directive was first introduced in the v0.8.0 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_max_running_timers <count></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_max_running_timers 256</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_sa_restart","When enabled, this module will set the SA_RESTART flag on Nginx workers signal dispositions.","<p dir=\"auto\">When enabled, this module will set the <code>SA_RESTART</code> flag on Nginx workers signal dispositions.</p><p dir=\"auto\">This allows Lua I/O primitives to not be interrupted by Nginx's handling of various signals.</p><p dir=\"auto\">This directive was first introduced in the <code>v0.10.14</code> release.</p>",["When enabled, this module will set the SA_RESTART flag on Nginx workers signal dispositions.","This allows Lua I/O primitives to not be interrupted by Nginx's handling of various signals.","This directive was first introduced in the v0.10.14 release."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_sa_restart on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_sa_restart on</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"],
[4,"lua_worker_thread_vm_pool_size","Specifies the size limit of the Lua VM pool (default 100) that will be used in the ngx.run_worker_thread API.","<p dir=\"auto\">Specifies the size limit of the Lua VM pool (default 100) that will be used in the <a href=\"#ngxrun_worker_thread\">ngx.run_worker_thread</a> API.</p><p dir=\"auto\">Also, it is not allowed to create Lua VMs that exceeds the pool size limit.</p><p dir=\"auto\">The Lua VM in the VM pool is used to execute Lua code in separate thread.</p><p dir=\"auto\">The pool is global at Nginx worker level. And it is used to reuse Lua VMs between requests.</p>",["Specifies the size limit of the Lua VM pool (default 100) that will be used in the ngx.run_worker_thread API.","Also, it is not allowed to create Lua VMs that exceeds the pool size limit.","The Lua VM in the VM pool is used to execute Lua code in separate thread.","The pool is global at Nginx worker level. And it is used to reuse Lua VMs between requests."],"<table ><tr><th>Syntax:</th><td><code><strong>lua_worker_thread_vm_pool_size <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_worker_thread_vm_pool_size 100</pre></td></tr><tr><th>Context:</th><td><code>http</code></td></tr></table>"]
]